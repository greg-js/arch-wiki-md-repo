Ссылки по теме

*   [Fail2ban](/index.php/Fail2ban "Fail2ban")
*   [Nftables (Русский)](/index.php/Nftables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Nftables (Русский)")
*   [Sshguard](/index.php/Sshguard "Sshguard")
*   [Simple stateful firewall (Русский)](/index.php/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Simple stateful firewall (Русский)")
*   [Sysctl#TCP/IP stack hardening](/index.php/Sysctl#TCP/IP_stack_hardening "Sysctl")
*   [Uncomplicated Firewall](/index.php/Uncomplicated_Firewall "Uncomplicated Firewall")

**Состояние перевода:** На этой странице представлен перевод статьи [iptables](/index.php/Iptables "Iptables"). Дата последней синхронизации: 17 октября 2019\. Вы можете [помочь](/index.php/ArchWiki_Translation_Team_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "ArchWiki Translation Team (Русский)") синхронизировать перевод, если в английской версии произошли [изменения](https://wiki.archlinux.org/index.php?title=Iptables&diff=0&oldid=585505).

*iptables* — утилита командной строки для настройки интегрированного в ядро Linux [межсетевого экрана](/index.php/Firewall "Firewall"), разработка которого велась в рамках проекта [Netfilter](https://en.wikipedia.org/wiki/ru:Netfilter существует утилита *ip6tables*. В основном их синтаксис совпадает, но есть специфичные для каждого протокола опции.

<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none">

## Contents

<label class="toctogglelabel" for="toctogglecheckbox"></label>

*   [1 Установка](#Установка)
    *   [1.1 Интерфейс](#Интерфейс)
        *   [1.1.1 Консольный](#Консольный)
        *   [1.1.2 Графический](#Графический)
*   [2 Основные понятия](#Основные_понятия)
    *   [2.1 Таблицы](#Таблицы)
    *   [2.2 Цепочки](#Цепочки)
    *   [2.3 Правила](#Правила)
    *   [2.4 Прохождение по цепочке](#Прохождение_по_цепочке)
    *   [2.5 Модули](#Модули)
*   [3 Настройка и запуск iptables](#Настройка_и_запуск_iptables)
    *   [3.1 Настройка из командной строки](#Настройка_из_командной_строки)
        *   [3.1.1 Отображение текущих правил](#Отображение_текущих_правил)
        *   [3.1.2 Сброс правил](#Сброс_правил)
        *   [3.1.3 Редактирование правил](#Редактирование_правил)
    *   [3.2 Руководства по настройке iptables](#Руководства_по_настройке_iptables)
*   [4 Логирование](#Логирование)
    *   [4.1 Ограничение скорости логирования](#Ограничение_скорости_логирования)
    *   [4.2 Просмотр логированных пакетов](#Просмотр_логированных_пакетов)
    *   [4.3 syslog-ng](#syslog-ng)
    *   [4.4 ulogd](#ulogd)
*   [5 Смотрите также](#Смотрите_также)

## Установка

Стандартная сборка ядра Arch Linux включает в себя поддержку iptables. Все, что потребуется – [установить](/index.php/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D1%8C "Установить") пользовательские утилиты, предоставляемые пакетом [iptables](https://www.archlinux.org/packages/?name=iptables) из [официальных репозиториев](/index.php/Official_repositories_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Official repositories (Русский)"). Пакет [iptables](https://www.archlinux.org/packages/?name=iptables) является косвенной зависимостью [мета-пакета](/index.php/%D0%9C%D0%B5%D1%82%D0%B0-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%B0 "Мета-пакета") [base](https://www.archlinux.org/packages/?name=base), поэтому он уже должен быть установлен.

### Интерфейс

#### Консольный

*   **Arno's firewall** — Безопасный межсетевой экран как для одиночной машины, так и для разрозненной сети. Лёгок в настройке, удобен в использовании, хорошо кастомизируется. Поддерживает: NAT и SNAT, проброс портов, ADSL ethernet-модемы со статическими и динамическими IP-адресами, фильтрация MAC-адресов, обнаружение скрытого сканирования портов, DMZ и DMZ-2-LAN пересылка, защита от SYN/ICMP флуда, обширное логирование с временными ограничениями для предотвращения засорения логов, все IP-протоколы и технологии VPN, такие как IPsec, плагины для расширения функциональности.

	[http://rocky.eld.leidenuniv.nl/](http://rocky.eld.leidenuniv.nl/) || [arno-iptables-firewall](https://aur.archlinux.org/packages/arno-iptables-firewall/)

*   **ferm** — Инструмент для обслуживания комплексных межсетевых экранов, помогающий избежать необходимости переписывать сложные правила снова и снова. Позволяет сохранить целый набор правил в одном файле и загрузить его всего одной командой. Настройка экрана производится посредством специального языка, наподобие языка программирования, с помощью уровней и списков.

	[http://ferm.foo-projects.org/](http://ferm.foo-projects.org/) || [ferm](https://www.archlinux.org/packages/?name=ferm)

*   **[FireHOL](https://en.wikipedia.org/wiki/FireHOL "wikipedia:FireHOL")** — Не только программа для создания межсетевого экрана, но и специальный язык для задания его настроек. Делает даже тонкую настройку экрана лёгкой — как вам бы и хотелось.

	[http://firehol.sourceforge.net/](http://firehol.sourceforge.net/) || [firehol](https://aur.archlinux.org/packages/firehol/)

*   **Firetable** — Инструмент для межсетевого экрана *iptables*. Каждый интерфейс настраивается отдельно в соответствии с собственным файлом настроек, синтаксис которого понятен и удобен.

	[https://gitlab.com/hsleisink/firetable](https://gitlab.com/hsleisink/firetable) || [firetable](https://aur.archlinux.org/packages/firetable/)

*   **[firewalld](/index.php/Firewalld "Firewalld") (firewall-cmd)** — Демон и консольный интерфейс для настройки сети, зональной политики и правил межсетевого экрана.

	[https://firewalld.org/](https://firewalld.org/) || [firewalld](https://www.archlinux.org/packages/?name=firewalld)

*   **[Shorewall](/index.php/Shorewall "Shorewall")** — Высокоуровневый инструмент для настройки *Netfilter*. Требования к экрану/шлюзу описываются посредством записей в наборе файлов настроек.

	[http://www.shorewall.net/](http://www.shorewall.net/) || [shorewall](https://www.archlinux.org/packages/?name=shorewall)

*   **[Uncomplicated Firewall](/index.php/Uncomplicated_Firewall "Uncomplicated Firewall")** — Простой интерфейс для *iptables*.

	[https://launchpad.net/ufw](https://launchpad.net/ufw) || [ufw](https://www.archlinux.org/packages/?name=ufw)

*   **[PeerGuardian](/index.php/PeerGuardian_Linux "PeerGuardian Linux") (pglcmd)** — Ориентированное на приватность firewall-приложение. Занимается блокировкой входящих и исходящих подключений на основе огромного чёрного списка (тысячи или даже миллионы IP-диапазонов).

	[http://sourceforge.net/projects/peerguardian/](http://sourceforge.net/projects/peerguardian/) || [pgl](https://aur.archlinux.org/packages/pgl/)

*   **Vuurmuur** — Мощный менеджер сетевого экрана. Лёгкая в освоении настройка, которая позволяет создавать как простые, так и сложные конфигурации межсетевого экрана. Для настройки есть графический интерфейс на основе [ncurses](https://www.archlinux.org/packages/?name=ncurses), который позволяет осуществлять безопасное удалённое администрирование через SSH или консоль. *Vuurmuur* поддерживает ограничение трафика, имеет мощную систему мониторинга, которая позволяет администратору следить за логами, подключениями и использованием пропускной способности в режиме реального времени.

	[https://www.vuurmuur.org/](https://www.vuurmuur.org/) || [vuurmuur](https://aur.archlinux.org/packages/vuurmuur/)

#### Графический

*   **Firewall Builder** — Графический интерфейс для настройки и управления межсетевыми экранами, работает с iptables (netfilter), ipfilter, pf, ipfw, Cisco PIX (FWSM, ASA), а также с маршрутизаторами Cisco с поддержкой Extended ACL. Запускается на Linux, FreeBSD, OpenBSD, Windows и macOS, может управлять как локальными, так и удалёнными межсетевыми экранами.

	[http://fwbuilder.sourceforge.net/](http://fwbuilder.sourceforge.net/) || [fwbuilder](https://www.archlinux.org/packages/?name=fwbuilder)

*   **[firewalld](https://en.wikipedia.org/wiki/firewalld "wikipedia:firewalld") (firewall-config)** — Демон и графический интерфейс для настройки сети, зональной политики и правил межсетевого экрана.

	[https://firewalld.org/](https://firewalld.org/) || [firewalld](https://www.archlinux.org/packages/?name=firewalld)

*   **[Gufw](/index.php/Uncomplicated_Firewall#Gufw "Uncomplicated Firewall")** — Графический GTK-интерфейс для [ufw](https://www.archlinux.org/packages/?name=ufw), который, в свою очередь, является интерфейсом [командной строки](#Консольный) для iptables (gufw–>ufw–>iptables), лёгкий и простой в использовании.

	[https://gufw.org/](https://gufw.org/) || [gufw](https://www.archlinux.org/packages/?name=gufw)

*   **[PeerGuardian](/index.php/PeerGuardian_Linux "PeerGuardian Linux") GUI (pglgui)** — Ориентированное на приватность firewall-приложение. Занимается блокировкой входящих и исходящих подключений на основе огромного чёрного списка (тысячи или даже миллионы IP-диапазонов).

	[https://sourceforge.net/projects/peerguardian/](https://sourceforge.net/projects/peerguardian/) || [pgl](https://aur.archlinux.org/packages/pgl/)

*   **FireStarter** — Высокоуровневый графический интерфейс межсетевого экрана Iptables для Linux.

	[http://www.fs-security.com/](http://www.fs-security.com/) || [firestarter](https://aur.archlinux.org/packages/firestarter/)

## Основные понятия

iptables используется для проверки, модификации, перенаправления и отбрасывания пакетов. Код для фильтрации пакетов IPv4 уже встроен в ядро. Он основан на наборе **таблиц**, каждая из которых служит конкретной цели. Таблицы составляют набор предопределенных **цепочек**, которые, в свою очередь, содержат список **правил**, организованных в определенном порядке. Каждое правило состоит из критерия (набора условий) и действия, которое применяется к пакетам, подпадающим под этот критерий, то есть, если все условия выполнены. iptables является утилитой, которая позволяет вам работать с этими цепочками и правилами. Большинство пользователей находят IP маршрутизацию в Linux сложной и запутанной, однако, на практике наиболее распространенные варианты использования (NAT и/или межсетевой экран для интернета) являются значительно менее сложными.

Ключ к пониманию принципа работы в этой [блок-схеме](http://www.frozentux.net/iptables-tutorial/images/tables_traverse.jpg). Слова в нижнем регистре наверху каждого блока являются именами таблиц, а слова в верхнем регистре – цепочками. Каждый пакет IP, который принимается на *любом* сетевом интерфейсе, проходит через эту блок-схему сверху вниз. Часто возникает заблуждение в том, что пакеты, приходящие, скажем, на внутренний интерфейс, обрабатываются каким-то иным образом нежели те, что приходят на интерфейс, подключенный к интернету. Пакеты со всех интерфейсов обрабатываются одинаково; это *ваша* задача в том, чтобы написать правила, которые будут обрабатывать их по-разному. Конечно, некоторые пакеты предназначены для локальных процессов, следовательно, они проходят через верхний блок на блок-схеме и останавливаются на блоке <Local Process> (локальный процесс), в то время как пакеты, которые генерируются локальными процессами, начинают проходить по схеме с блока <Local Process> и продолжают движение вниз. Более подробное описание этой блок-схемы вы можете найти [на этой странице](http://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#TRAVERSINGOFTABLES).

В подавляющем большинстве случаев вам не придется использовать таблицы raw, mangle и security. Приведенная ниже схема изображает упрощенный вариант прохождения пакета через iptables:

```
                               XXXXXXXXXXXXXXXXXX
                             XXX      Сеть      XXX
                               XXXXXXXXXXXXXXXXXX
                                       +
                                       |
                                       v
+---------------+             +-------------------+
|таблица: filter| <---+       |таблица: nat       |
|цепочка: INPUT |     |       |цепочка: PREROUTING|
+-------+-------+     |       +--------+----------+
        |             |                |
        v             |                v
[локальный процесс]   |         ***************          +----------------+
        |             +-------+  Маршрутизация  +------> |таблица: filter |
        v                       ***************          |цепочка: FORWARD|
 ***************                                         +-------+--------+
  Маршрутизация                                                  |
 ***************                                                 |
        |                                                        |
        v                       ***************                  |
+---------------+     +------>   Маршрутизация   <---------------+
|таблица: nat   |     |         ***************
|цепочка: OUTPUT|     |                +
+------+--------+     |                |
        |             |                v
        v             |      +---------------------+
+---------------+     |      | таблица: nat        |
|таблица: filter| +---+      | цепочка: POSTROUTING|
|цепочка: OUTPUT|            +---------+-----------+
+---------------+                      |
                                       v
                               XXXXXXXXXXXXXXXXXX
                             XXX      Сеть      XXX
                               XXXXXXXXXXXXXXXXXX

```

### Таблицы

iptables содержит пять таблиц:

1.  `raw` используется только для настройки пакетов, поэтому они освобождаются от отслеживания.
2.  `filter` – это таблица по умолчанию, в которой сосредоточены все действия типичные для межсетевых экранов.
3.  `nat` используется для [преобразования сетевых адресов](https://en.wikipedia.org/wiki/ru:NAT "wikipedia:ru:NAT") (например, проброс портов).
4.  `mangle` служит для специальных преобразований пакетов (смотрите также [Преобразованный пакет](https://en.wikipedia.org/wiki/Mangled_packet "wikipedia:Mangled packet")).
5.  `security` используется для [контроля доступа](/index.php/Security_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Контроль_доступа "Security (Русский)") (например, SELinux – смотрите [эту статью](http://lwn.net/Articles/267140/) для получения подробной информации).

Скорее всего, вам нужно будет использовать только две из них: **filter** и **nat**. Остальные таблицы используются в сложных конфигурациях затрагивающих множество маршрутизаторов и точек маршрутизации и в любом случае выходят за рамки данной статьи.

### Цепочки

Таблицы состоят из цепочек, которые состоят из списка правил, расположенных в определенном порядке. Таблица по умолчанию, filter, содержит три встроенные цепочки: `INPUT`, `OUTPUT` и `FORWARD`, которые активируются в разных точках процесса фильтрации пакетов, как показано на [диаграмме](http://www.frozentux.net/iptables-tutorial/chunkyhtml/images/tables_traverse.jpg). Таблица nat включает стандартные цепочки `PREROUTING`, `POSTROUTING`, и `OUTPUT`.

Описания стандартных цепочек для других таблиц вы можете найти в руководстве [iptables(8)](https://jlk.fjfi.cvut.cz/arch/manpages/man/iptables.8).

По умолчанию, все цепочки пустые и не содержат каких-либо правил. Ваша задача в том, чтобы добавить правила в цепочки, которые вы хотите использовать. У цепочек, однако, есть стандартное правило (политика), которое в основном имеет действие `ACCEPT`, но может (и должно) быть изменено на `DROP`, если вы хотите быть уверены в том, что даже если пакет проскочит сквозь набор ваших правил, он будет отброшен. Стандартное правило применяется к пакетам только тогда, когда они достигают конца цепочки, пройдя по остальным правилам.

Пользовательские цепочки могут быть добавлены для упорядочивания наборов правил, а также для повышения эффективности работы iptables. Пример создания таких цепочек вы можете найти на странице [Простой межсетевой экран с внутренним состоянием](/index.php/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Simple stateful firewall (Русский)").

### Правила

Фильтрация пакетов основана на правилах, каждое из которых задается набором **условий** и целевым **действием**. Если пакет соответствует всем условиям, к нему будет применено указанное действие. Типовые условия могут проверять, например, с какого интерфейса пришел пакет (например, eth0 или eth1), какого он типа (ICMP, TCP или UDP), или на какой порт пакет направляется.

Целевое действие указывается с помощью опций `-j` или `--jump`. Действием может быть одно из стандартных действий, действий расширений или переход на пользовательскую цепочку. Стандартные действия включают `ACCEPT`, `DROP`, `QUEUE` и `RETURN`. Примерами действия расширений могут быть `REJECT` и `LOG`. Если применено одно из стандартных действий, участь пакета решается незамедлительно и обработка пакета в таблице прекращается. Если действием указан переход на пользовательскую цепочку, и пакет проходит через нее, он возвращается на исходную цепочку и продолжает со следующего после перехода правила. Действия расширений могут быть **терминальными** (как стандартные действия) или **нетерминальными** (как пользовательские цепочки). Смотрите также [iptables-extensions(8)](https://jlk.fjfi.cvut.cz/arch/manpages/man/iptables-extensions.8) для получения более подробной информации.

### Прохождение по цепочке

Принятый на сетевом интерфейсе пакет проходит по цепочкам таблиц в порядке, изображенном на [диаграмме](http://www.frozentux.net/iptables-tutorial/chunkyhtml/images/tables_traverse.jpg). На первой точке маршрутизации (routing decision) принимается решение, направляется ли пакет на локальную машину (в таком случае пакет проходит через цепочки INPUT) или куда-то в другое место (в этом случае пакет проходит через цепочки FORWARD). На второй точке маршрутизации принимается решение, на какой сетевой интерфейс перенаправить исходящий пакет. В каждой цепочке по пути следования пакета, для каждого из правил, в которых удовлетворяются все условия, выполняется соответствующее действие. Три наиболее часто используемые действия – `ACCEPT`, `DROP` и переход на пользовательскую цепочку. В противоположность стандартным цепочкам, которые имеют действия по умолчанию, цепочки пользователя такого действия не имеют. Если не удовлетворены условия ни одного из правил пользовательской цепочки, пакет возвращается обратно в вызвавшую ее цепочку, как изображено [здесь](http://www.frozentux.net/iptables-tutorial/images/table_subtraverse.jpg). Если в какое-то время выполнились все условия цепочки с действием `DROP`, пакет немедленно отбрасывается и над ним более не производится никаких действий. Обратите, однако, внимание, что если пакет **принят** действием `ACCEPT`, он принимается только на уровне текущей цепочки и всех вышележащих цепочках в текущем стеке вызовов. Он не обрабатывается более той стандартной цепочкой, которая инициировала последовательность переходов, но продолжает проходить по следующим цепочкам в других таблицах, в порядке, изображенном на диаграмме.

### Модули

Существует множество модулей которые могут использоваться для расширения возможностей iptables, такие как connlimit, conntrack, limit и recent. Эти модули дополняют iptables новой функциональностью для того, чтобы были возможны более сложные правила фильтрации.

## Настройка и запуск iptables

*iptables* является службой [systemd](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Systemd (Русский)") и [запускается](/index.php/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%8C "Запустить") соответствующим образом. Пакет [iptables](https://www.archlinux.org/packages/?name=iptables) при установке добавляет начальный комплект правил в файл `/etc/iptables/iptables.rules`, который загружается при первом [запуске](/index.php/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%8C "Запустить") службы `iptables.service`. Если вы хотите настроить автоматическую загрузку *iptables* при запуске системы, то необходимо [включить](/index.php/%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D1%8C "Включить") соответствующую службу.

Правила *iptables* для IPv6 по умолчанию хранятся в файле `/etc/iptables/ip6tables.rules`, который используется службой `ip6tables.service`. Эту службу можно запустить так же, как и `iptables.service`.

После добавления правил посредством [командной строки](#Настройка_из_командной_строки) файл настроек не изменится автоматически — необходимо сохранять изменения командой

```
# iptables-save -f /etc/iptables/iptables.rules

```

Если вы изменяли файл настроек вручную, нужно либо [перезапустить](/index.php/%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%8C "Перезапустить") *iptables*, либо загрузить его посредством команды

```
# iptables-restore /etc/iptables/iptables.rules

```

### Настройка из командной строки

#### Отображение текущих правил

Основная команда для отображения текущих правил — `iptables --list-rules` (`-S`), вывод которой похож на вывод утилиты *iptables-save*. Разница между ними заключается в том, что по умолчанию последняя из них выводит правила из всех таблиц, в то время как *iptables* — только из таблицы `filter`.

При работе с iptables из командной строки команда `--list` (`-L`) позволяет добавить больше модификаторов и вывести больше информации. Например, чтобы проверить текущий набор правил и количество срабатываний каждого из них используйте команду:

 `# iptables -nvL` 
```
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination
```

Если вывод команды выглядит как в примере выше, это значит, что правила не заданы, все пакеты пропускаются.

Чтобы показать номера строк при просмотре правил, запустите команду с опцией `--line-numbers`. Это полезно во время добавления и удаления отдельных правил.

#### Сброс правил

Вы можете сбросить правила iptables, используя эти команды:

```
# iptables -F
# iptables -X
# iptables -t nat -F
# iptables -t nat -X
# iptables -t mangle -F
# iptables -t mangle -X
# iptables -t raw -F
# iptables -t raw -X
# iptables -t security -F
# iptables -t security -X
# iptables -P INPUT ACCEPT
# iptables -P FORWARD ACCEPT
# iptables -P OUTPUT ACCEPT

```

Опция `-F` без аргументов просто очищает все цепочки в текущей таблице. Аналогично, опция `-X` удаляет все пустые пользовательские цепочки в таблице.

Отдельные цепочки могут быть очищены от правил или удалены указанием имени цепочки после опциям `-F` и `-X` соответственно.

#### Редактирование правил

Новые правила могут быть добавлены в конец цепочки либо на указанное по индексу место в цепочке.

Обратите внимание, что примеры здесь приведены из соображения, что ваш компьютер не выполняет роль [маршрутизатора](/index.php/Router "Router"). Поэтому, первым делом, мы поменяем стандартное действие цепочки `FORWARD` с `ACCEPT` на `DROP`:

```
# iptables -P FORWARD DROP

```

**Важно:** Этот раздел не претендует на роль руководства по обеспечению защиты серверов. Его назначение всего лишь в том, чтобы научить синтаксису и принципам правил iptables. Для усиления безопасности вашей системы, обратитесь к страницам [простой межсетевой экран с внутренним состоянием](/index.php/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Simple stateful firewall (Русский)") для получения минимальной безопасной конфигурации и [безопасность](/index.php/Security_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Security (Русский)") для защиты системы в целом.

Возможность синхронизации по локальной сети в [Dropbox](https://en.wikipedia.org/wiki/ru:Dropbox "wikipedia:ru:Dropbox") использует отсылку [широковещательных пакетов каждые 30 секунд](https://isc.sans.edu/port.html?port=17500) всем доступным компьютерам сети. Если нам посчастливилось быть в одной сети с клиентами Dropbox и нам эта возможность не нужна, мы можем добавить правило для отбрасывания таких пакетов:

```
# iptables -A INPUT -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable

```

```
# iptables -nvL --line-numbers

```

```
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination
1        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

```

**Примечание:** Здесь мы использовали действие `REJECT`, а не `DROP`, так как [RFC 1122, раздел 3.3.8](https://tools.ietf.org/html/rfc1122#page-69) требует, чтобы хосты возвращали ошибки ICMP всегда, когда это возможно вместо просто игнорирования отбрасываемых пакетов. [На этой странице](http://www.chiark.greenend.org.uk/~peterb/network/drop-vs-reject) поясняется, почему почти всегда `REJECT` лучше чем `DROP`.

Теперь, скажем мы поменяли наш взгляд касательно Dropbox и решили установить его на наш компьютер. Мы также хотим использовать возможность синхронизации по локальной сети, но только с единственным компьютером в сети, IP-адрес которого нам известен, пусть это будет, например, `10.0.0.85`. Нам следует использовать ключ `-R` для того, чтобы заменить старое правило новым:

```
# iptables **-R** INPUT **1** -p tcp --dport 17500 **! -s 10.0.0.85** -j REJECT --reject-with icmp-port-unreachable

```

```
# iptables -nvL --line-numbers

```

```
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination
1        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

```

Теперь новое правило позволит хосту `10.0.0.85` отправить данные на порт `17500` нашего компьютера. Но теперь мы поняли, что наше правило не самое удачное: новые правила в этой цепочке смогут все равно заблокировать пакет. Мы не просто хотим пропустить пакет дальше по цепочке, а хотим сразу пометить его как принятый и пропустить в другие цепочки.

Здесь мы используем ключ `-I` для того, чтобы вставить новое правило в самое начало цепочки, перед старым:

```
# iptables **-I** INPUT -p tcp --dport 17500 -s 10.0.0.85 -j ACCEPT -m comment --comment "Friendly Dropbox"

```

Мы установили также комментарий к правилу, который теперь отображается рядом с ним в списке:

```
# iptables -nvL --line-numbers

```

```
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination
1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */
2        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

```

Второе правило теперь можно переписать так, чтобы оно отбрасывало пакеты, приходящие на порт `17500` с других хостов:

```
# iptables -R INPUT 2 -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable

```

Наш итоговый список правил теперь выглядит следующим образом:

```
# iptables -nvL --line-numbers

```

```
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination
1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */
2        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable

Chain FORWARD (policy DROP 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
num   pkts bytes target     prot opt in     out     source               destination

```

### Руководства по настройке iptables

*   [Простой межсетевой экран с внутренним состоянием](/index.php/Simple_stateful_firewall_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Simple stateful firewall (Русский)")
*   [Маршрутизатор](/index.php/Router "Router")

## Логирование

Действие `LOG` полезно для логирования пакетов, когда к нему применяется правило. В отличие от других действий вроде `ACCEPT` или `DROP`, `LOG` ничего не делает с пакетом, он просто продолжает свое продвижение по цепочке. Обычно условия для правила с действием `LOG` полностью дублируют условия какого-нибудь другого правила, которое следует логировать, а само логирующее правило идет непосредственно перед ним. Это значит, что, например, если вы хотите включить логирование всех отброшенных пакетов, вам следует добавить правило с действием `LOG` перед **каждым** правилом с `DROP`. Это не слишком удобно и плохо влияет на эффективность, поэтому вы можете вместо этого создать пользовательскую цепочку, скажем, `logdrop`:

```
# iptables -N logdrop

```

И добавить в нее следующие правила:

```
# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG
# iptables -A logdrop -j DROP

```

В разделе [#Ограничение скорости логирования](#Ограничение_скорости_логирования) дано разъяснение опций `limit` и `limit-burst`. Теперь, когда мы захотим отбросить пакет и добавить запись в лог об этом, мы просто выполним переход на цепочку `logdrop`:

```
# iptables -A INPUT -m conntrack --ctstate INVALID -j logdrop

```

### Ограничение скорости логирования

Цепочка `logdrop` из предыдущего раздела использует модуль `limit`, который служит для предотвращения разрастания лога и падения эффективности при частых операциях записи на диск, ограничивая скорость логирования. Без этого, недобросовестный пользователь может быстро заполнить все свободное пространство вашего диска (как минимум, раздела `/var`), посылая вам мусорные пакеты.

Опция `-m limit` используется для вызова модуля `limit`. Вы можете использовать опции `--limit` чтобы указать среднюю допустимую скорость логирования и `--limit-burst` для определения ограничения количества пакетов, принятых за раз. Например, команда из предыдущего раздела,

```
# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG

```

добавляет правило в цепочку `logdrop`, которое логирует все проходящие через него пакеты. За короткое время только 10 пакетов будут добавлены в лог, а затем максимальная скорость логирования не будет превышать 5 пакетов в минуту. Если скорость приходящих пакетов станет ниже 5 в минуту, со временем возможность принять 10 пакетов в пике восстановится. Эти опции работают подобно бассейну с постоянной скоростью оттока, но переменной скоростью притока. Если вода заливается очень быстро, бассейн переполняется и приток приходится сокращать (скорость логирования становится ограниченной значением `limit`, то есть, скорости оттока). Но, если дать возможность бассейну опустеть, он снова сможет принять большое количество воды за раз (равное значению `limit-burst`), пока вновь не заполнится.

### Просмотр логированных пакетов

Логированные пакеты сохраняются как сообщения ядра в [журнале systemd](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)/Journal_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Systemd (Русский)/Journal (Русский)").

Чтобы отобразить все пакеты, которые были залогированы с момента последнего перезапуска, выполните

```
# journalctl -k | grep "IN=.*OUT=.*" | less

```

### syslog-ng

Если вы используете [syslog-ng](/index.php/Syslog-ng "Syslog-ng"), вы можете настроить куда будут попадать записи лога iptables. Замените:

```
filter f_everything { level(debug..emerg) and not facility(auth, authpriv); };

```

на

```
filter f_everything { level(debug..emerg) and not facility(auth, authpriv) and not filter(f_iptables); };

```

Это предотвратит попадание вывода iptables в `/var/log/everything.log`.

Если вы также хотите чтобы лог iptables записывался в какой-нибудь другой файл вместо `/var/log/iptables.log`, вы можете просто изменить путь назначения `d_iptables` здесь же (`syslog-ng.conf`):

```
destination d_iptables { file("/var/log/iptables.log"); };

```

### ulogd

[ulogd](http://www.netfilter.org/projects/ulogd/index.html) – это специализированный демон логирования пакетов пользовательского уровня для netfilter, который может заменить стандартное действие `LOG`. Пакет [ulogd](https://www.archlinux.org/packages/?name=ulogd) доступен в [официальных репозиториях](/index.php/Official_repositories_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Official repositories (Русский)").

## Смотрите также

*   [Iptables в Википедии](https://en.wikipedia.org/wiki/ru:iptables "wikipedia:ru:iptables")
*   [Port knocking](/index.php/Port_knocking "Port knocking")
*   [Официальный сайт iptables](http://www.netfilter.org/projects/iptables/index.html)
*   [Руководство по iptables версии 1.2.2](http://www.frozentux.net/iptables-tutorial/iptables-tutorial.html) от Oskar Andreasson
*   [Debian Wiki — iptables](http://wiki.debian.org/iptables)
*   [Безопасное использование Connection Tracking helpers](https://home.regit.org/netfilter-en/secure-use-of-helpers/)