Ссылки по теме

*   [systemd (Русский)](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Systemd (Русский)")
*   [Автоматический вход в виртуальную консоль](/index.php/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B2%D1%85%D0%BE%D0%B4_%D0%B2_%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%83%D1%8E_%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C "Автоматический вход в виртуальную консоль")
*   [xinitrc (Русский)#Автозапуск X при входе в систему](/index.php/Xinitrc_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Автозапуск_X_при_входе_в_систему "Xinitrc (Русский)")

**Состояние перевода:** На этой странице представлен перевод статьи [systemd/User](/index.php/Systemd/User "Systemd/User"). Дата последней синхронизации: 9 Декабря 2016‎. Вы можете [помочь](/index.php/ArchWiki_Translation_Team_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "ArchWiki Translation Team (Русский)") синхронизировать перевод, если в английской версии произошли [изменения](https://wiki.archlinux.org/index.php?title=Systemd/User&diff=0&oldid=458617).

[systemd](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Systemd (Русский)") предоставляет пользователям возможность управления и контроля службами с отдельными процессами systemd для каждого пользователя, что позволяет ему запускать, останавливать, включать и отключать свои собственные службы. Это удобно применять для демонов и других служб, которые обычно выполняются для одного пользователя, например, [mpd](/index.php/Music_Player_Daemon_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Music Player Daemon (Русский)") или для выполнения автоматизированных задач, таких как выборка почты. С некоторыми предостережениями можно даже запустить Xorg и весь оконный менеджер с помощью пользовательских служб.

## Contents

*   [1 Как это работает](#Как_это_работает)
*   [2 Основные настройки](#Основные_настройки)
    *   [2.1 Переменные окружения](#Переменные_окружения)
        *   [2.1.1 Пример службы](#Пример_службы)
        *   [2.1.2 DISPLAY и XAUTHORITY](#DISPLAY_и_XAUTHORITY)
        *   [2.1.3 PATH](#PATH)
        *   [2.1.4 pam_environment](#pam_environment)
    *   [2.2 Автоматический запуск systemd от имени пользователя](#Автоматический_запуск_systemd_от_имени_пользователя)
*   [3 Написание пользовательских юнитов](#Написание_пользовательских_юнитов)
    *   [3.1 Пример](#Пример)
    *   [3.2 Пример с переменными](#Пример_с_переменными)
    *   [3.3 Примечание о приложениях X](#Примечание_о_приложениях_X)
    *   [3.4 Чтение журнала](#Чтение_журнала)
*   [4 Временные файлы](#Временные_файлы)
*   [5 Xorg и systemd](#Xorg_и_systemd)
    *   [5.1 Автоматический логин в Xorg без экранного менеджера](#Автоматический_логин_в_Xorg_без_экранного_менеджера)
    *   [5.2 Xorg как служба systemd пользователь](#Xorg_как_служба_systemd_пользователь)
*   [6 Некоторые случаи использования](#Некоторые_случаи_использования)
    *   [6.1 Постоянный терминальный мультиплексор](#Постоянный_терминальный_мультиплексор)
    *   [6.2 Оконный менеджер](#Оконный_менеджер)
*   [7 Сделать kill процесса при выходе из системы](#Сделать_kill_процесса_при_выходе_из_системы)
*   [8 Смотрите также](#Смотрите_также)

## Как это работает

В соответствии с конфигурацией по умолчанию в `/etc/pam.d/system-login`, модуль `pam_systemd` автоматически запускает `systemd --user` в случае, когда пользователь в первый раз входит в систему . Этот процесс будет работать до тех пор, пока существует сессия этого пользователя, и будет убит, как только последний сеанс для пользователя будет закрыт. Когда включен [#Автоматический запуск systemd от имени пользователя](#Автоматический_запуск_systemd_от_имени_пользователя), то процесс запускается при загрузке и убит не будет. Пользовательский процесс systemd отвечает за управление службами пользователей, которые могут быть использованы для запуска демонов или автоматизированных задач, со всеми преимуществами systemd, таких как активация сокета, таймеры, системы зависимостей или строгий контроль процесса через контрольные группы.

Аналогично системным службам, пользовательские службы расположены в следующих каталогах (отсортированы по возрастанию приоритета):

*   `/usr/lib/systemd/user/` где находятся службы, относящиеся к установленным пакетам.
*   `~/.local/share/systemd/user/` где находятся службы, относящиеся к пакетам, установленным в домашний каталог.
*   `/etc/systemd/user/` где находятся общесистемные пользовательские службы, созданные системным администратором.
*   `~/.config/systemd/user/` где пользователь размещает свои собственные службы.

При запуске пользовательского процесса systemd, у Вас откроется целевой `default.target`. Другие службы могут управляться вручную с помощью команды `systemctl --user`.

**Примечание:**

*   Имейте в виду, что `systemd --user` представляет собой процесс для каждого пользователя, а не для сессии. Смысл заключается в том, что большая часть ресурсов, обрабатываемых пользовательскими службами, такие как сокеты или файлы состояния будут создаваться отдельно для каждого пользователя (в его домашнем каталоге), и не за один сеанс. Это означает, что все пользовательские службы работают вне сеанса. Как следствие, программы, которые должны быть запущены внутри сессии, вероятно, прервут выполнение пользовательских служб. С помощью systemd в пользовательском сеансе обрабатывается довольно много данных. См [[1]](https://mail.gnome.org/archives/desktop-devel-list/2014-January/msg00079.html) и [[2]](http://lists.freedesktop.org/archives/systemd-devel/2014-March/017552.html) для получения подсказок о том, как идут дела.
*   `systemd --user` выполняется как отдельный процесс от родительского `systemd --system` процесса. Службы пользователей не могут ссылаться или зависеть от системных устройств.

## Основные настройки

Все пользовательские службы размещаются в `~/.config/systemd/user/`. Если вы хотите запускать службы при первом входе в систему, выполните `systemctl --user enable *service*` для любой службы, которую вы хотите сделать автозагрузочной.

**Совет:** Если вы хотите включить службу для всех пользователей, а не для пользователя, выполняющего команду *systemctl* , запустите `systemctl --user --global enable *service*` от имени суперпользователя.

### Переменные окружения

Пользовательский процесс systemd не наследует какую-либо из [переменных окружения](/index.php/Environment_variables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Environment variables (Русский)"), установленных в `.bashrc` или других. Существует несколько способов установить переменные окружения для systemd:

1.  Для переменной `$HOME` пользовательского каталога, создайте файл *.conf* в каталоге `~/.config/environment.d/` со строками вида {{ic | 1 = NAME = VAL}. Применяется только к части пользовательских служб.

Смотрите [environment.d(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/environment.d.5) для получения дополнительной информации.

1.  Используйте опцию `DefaultEnvironment` в `/etc/systemd/user.conf`. Применяется ко всем пользовательским службам.
2.  Добавление конфигурационного файла в `/etc/systemd/system/user@.service.d/`. Применяется ко всем пользовательским процессам; см [#Пример службы](#Пример_службы)
3.  Для временного изменения используйте `systemctl --user set-environment` или `systemctl --user import-environment`. Применяется ко всем пользовательским службам, созданным после установки переменных окружения, но не к службам, которые уже были запущены.
4.  Используйте `dbus-update-activation-environment --systemd --all` команда обеспечивается [dbus](/index.php/Dbus "Dbus"). Имеет тот же эффект, что и `systemctl --user import-environment`, но так же влияет на сессию D-Bus. Вы можете добавить это в конец вашего файла инициализации оболочки.
5.  Для "глобальных" переменных среды для пользовательской среды вы можете использовать каталоги environment.d, которые анализируются генераторами systemd. Смотрите [environment.d(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/environment.d.5) для получения дополнительной информации.
6.  Вы также можете написать скрипт генератора среды, который может создавать переменные среды, которые варьируются от пользователя к пользователю. Это, вероятно, лучший способ, если вам нужны индивидуальные среды (это относится к XDG_RUNTIME_DIR, DBUS_SESSION_BUS_ADDRESS и т.д.). Смотрите [systemd.environment-generator(7)](https://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.environment-generator.7).

Одну переменную Вы можете установить в `PATH`. После настройки можно использовать команду `systemctl --user show-environment` для проверки правильности значений.

#### Пример службы

Создайте [drop-in](/index.php/Systemd#Drop-in_files "Systemd") каталог `/etc/systemd/system/user@.service.d/` и внутри создайте файл с расширением `.conf` (например, `local.conf`):

 `/etc/systemd/system/user@.service.d/local.conf` 
```
[Service]
Environment="PATH=/usr/lib/ccache/bin:/usr/local/bin:/usr/bin:/bin"
Environment="EDITOR=nano -c"
Environment="BROWSER=firefox"
Environment="NO_AT_BRIDGE=1"
```

#### DISPLAY и XAUTHORITY

Переменная `DISPLAY` используется любым графическим приложением, чтобы знать, какой дисплей использовать, `XAUTHORITY`, чтобы указать путь к пользовательскому файлу `.Xauthority`, а также куки, необходимые для запуска Х-сервера. Если Вы планируете запускать графические приложения из процесса systemd, то эти переменные обязательно должны быть установлены. Systemd предоставляет скрипт в `/etc/X11/xinit/xinitrc.d/50-systemd-user.sh` для импорта этих переменных в пользовательскую сессию systemd на запуск X. [[3]](https://github.com/systemd/systemd/blob/v219/NEWS#L194) Так что если Вы не запускаете Х нестандартным образом, пользовательские службы должны знать переменные `DISPLAY` и `XAUTHORITY`.

#### PATH

Если изменить `PATH` и запланированный запуск приложений, которые используют службу systemd, Вы должны убедиться, что модифицированный `PATH` установлен и в среде systemd. Если предположить, что Вы установили переменную `PATH` в `.bash_profile`, то лучшим способом сделать systemd осведомленным о модификации `PATH` будет добавление в `.bash_profile` после `PATH` заданной переменной:

 `~/.bash_profile` 
```
systemctl --user import-environment PATH

```

Обратите внимание, что это не повлияет на системные службы, запущенные до получения `~/.bash_profile`.

#### pam_environment

Переменные среды можно сделать доступными с помощью модуля `pam_env.so`. Смотрите [Environment variables#Using pam_env](/index.php/Environment_variables#Using_pam_env "Environment variables") для деталей конфигурации.

### Автоматический запуск systemd от имени пользователя

Пользовательский процесс systemd запускается сразу после первого входа пользователя в систему, и будет убит после завершения последнего сеанса пользователя. Иногда может быть полезно запустить службу сразу после загрузки, и поддерживать процесс systemd запущенным даже после завершения последнего сеанса пользователя, например, чтобы некоторый пользовательский процесс работал без какой-либо открытой сессии. Для этой цели используются долговременные службы. Используйте следующую команду, чтобы включить долговременную службу для конкретного пользователя:

```
# loginctl enable-linger *username*

```

**Важно:** служба systemd находится **вне** сессии, она запускается за пределами *logind*. Не используйте долговременные службы для включения автоматического входа в систему, иначе будет [перерыв в работе сессии](/index.php/General_troubleshooting_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Разрешения_сессии "General troubleshooting (Русский)").

## Написание пользовательских юнитов

Смотрите [systemd#Writing_unit_files](/index.php/Systemd#Writing_unit_files "Systemd") для получения общей информации о написании юнитов модулей systemd.

### Пример

Ниже приведен пример варианта пользовательской службы mpd.

 `~/.config/systemd/user/mpd.service` 
```
[Unit]
Description=Music Player Daemon

[Service]
ExecStart=/usr/bin/mpd --no-daemon

[Install]
WantedBy=default.target

```

### Пример с переменными

Ниже приведен пример пользовательской версии `sickbeard.service`, которая учитывает все переменные окружения пользовательских каталогов, где SickBeard может найти некоторые файлы:

 `~/.config/systemd/user/sickbeard.service` 
```
[Unit]
Description=SickBeard Daemon

[Service]
ExecStart=/usr/bin/env python2 /opt/sickbeard/SickBeard.py --config %h/.sickbeard/config.ini --datadir %h/.sickbeard

[Install]
WantedBy=default.target

```

Как указано в [systemd.unit(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/systemd.unit.5), переменная `%h` заменяется домашней директорией пользователя, запускающего службу. Есть и другие переменные, которые учитываются на странице руководства [systemd](/index.php/Systemd "Systemd").

### Примечание о приложениях X

Большинству приложений X для запуска нужна переменная `DISPLAY`. Смотрите [#DISPLAY и XAUTHORITY](#DISPLAY_и_XAUTHORITY), чтобы узнать, как установить эту переменную для всего пользовательского экземпляра systemd.

### Чтение журнала

Журнал для пользователя может быть прочитан с помощью аналогичной команды:

```
$ journalctl --user

```

Чтобы указать юнит, можно использовать

```
$ journalctl --user -u myunit.service

```

Эквивалентная команда

```
$ journalctl --user --user-unit myunit.service

```

Обратите внимание, что journald не будет писать пользовательские журналы для пользователей с UID ниже 1000, вместо этого [перенаправляя](https://github.com/systemd/systemd/blob/a33687b792908aa6c9f4c0b22e8935643ee0ddb6/src/journal/journald-server.c#L402) всё в системный журнал.

## Временные файлы

*systemd-tmpfiles* позволяет пользователям управлять нестабильными и временными файлами и каталогами так же, как общесистемным способом (см. [systemd#Temporary files](/index.php/Systemd#Temporary_files "Systemd")). Пользовательские файлы конфигурации считываются из `~/.config/user-tmpfiles.d/` и `~/.local/share/user-tmpfiles.d/` в указанном порядке. Для использования этой функциональности требуется включить необходимые пользовательские юниты systemd для вашего пользователя:

```
$ systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer

```

Синтаксис конфигурационных файлов такой же, как и для всей системы. Для получения дополнительной информации смотрите справочные страницы [systemd-tmpfiles(8)](https://jlk.fjfi.cvut.cz/arch/manpages/man/systemd-tmpfiles.8) и [tmpfiles.d(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/tmpfiles.d.5).

## Xorg и systemd

Есть несколько способов запустить xorg в системных модулях. Ниже представлены два варианта: либо запустить новый пользовательский сеанс с процессом xorg, либо запустить xorg из пользовательской службы systemd.

### Автоматический логин в Xorg без экранного менеджера

Эта опция запускает системный блок, который запускает сеанс пользователя с сервером xorg, а затем запускает обычный `~/.xinitrc` для запуска оконного менеджера и т.д.

Вам необходим установленный [xlogin-git](https://aur.archlinux.org/packages/xlogin-git/). Настройте свой xinitrc, как указано в разделе [Xinit#xinitrc](/index.php/Xinit#xinitrc "Xinit").

Сеанс будет использовать собственный dbus демон, но различные утилиты systemd будут автоматически подключаться к экземпляру `dbus.service`. Наконец, [enable](/index.php/Enable "Enable") службу `xlogin@*username*` для автоматического входа при загрузке.Сеанс пользователя полностью находится в области видимости systemd, и все в сеансе пользователя должно работать нормально.

### Xorg как служба systemd пользователь

Кроме того, [xorg](/index.php/Xorg "Xorg") можно запустить из службы пользователя systemd. Это хорошо, поскольку другие связанные с X юниты могут зависеть от xorg и т. д. Но с другой стороны, у этого есть некоторые недостатки, объясненные ниже.

[xorg-server](https://www.archlinux.org/packages/?name=xorg-server) обеспечивает интеграцию с systemd двумя способами:

*   Может быть запущен непривилегированным, делегируя управление устройствами logind (смотрите коммиты Hans de Goede [коммит](http://cgit.freedesktop.org/xorg/xserver/commit/?id=82863656ec449644cd34a86388ba40f36cea11e9)).
*   Может быть превращен в сервис, активируемый сокетом (смотрите [этот коммит](http://cgit.freedesktop.org/xorg/xserver/commit/?id=b3d3ffd19937827bcbdb833a628f9b1814a6e189)). Это устраняет необходимость в [systemd-xorg-launch-helper-git](https://aur.archlinux.org/packages/systemd-xorg-launch-helper-git/).

К сожалению, чтобы иметь возможность запускать xorg в непривилегированном режиме, он должен запускаться внутри сеанса. Итак, в данный момент недостаток запуска xorg в качестве пользовательской службы заключается в том, что он должен запускаться с привилегиями суперпользователя (как до 1.16) и не может использовать преимущества непривилегированного режима, представленного в 1.16.

**Примечание:** Это не является фундаментальным ограничением, налагаемым logind, но причина, по-видимому, заключается в том, что xorg нужно знать, какой сеанс взять на себя, и сейчас он получает эту информацию, вызывая [logind](http://www.freedesktop.org/wiki/Software/systemd/logind)'s `GetSessionByPID` используя свой собственный pid в качестве аргумента. Смотрите [this thread](http://lists.x.org/archives/xorg-devel/2014-February/040476.html) и [xorg sources](http://cgit.freedesktop.org/xorg/xserver/tree/hw/xfree86/os-support/linux/systemd-logind.c). Кажется вероятным, что xorg можно изменить, чтобы получить сеанс от tty, к которому он подключен, и затем он мог бы работать непривилегированным из пользовательской службы вне сеанса.

**Важно:** В xorg 1.18 активация сокета, кажется, сломана. Клиент, вызывающий активацию, зависает. Смотрите вышестоящий отчет об ошибках [[4]](https://bugs.freedesktop.org/show_bug.cgi?id=93072). В качестве временного обходного пути вы можете запустить сервер xorg без активации сокета, убедившись, что клиенты подключаются после задержки, поэтому сервер полностью запускается. Кажется, нет никакого удобного механизма, чтобы получить уведомление о запуске для X сервера.

Вот как запустить xorg из пользовательского сервиса:

1\. Заставить xorg работать с правами суперпользователя и для любого пользователя путем редактирования `/etc/X11/Xwrapper.config`

 `/etc/X11/Xwrapper.config` 
```
allowed_users=anybody
needs_root_rights=yes

```

2\. Добавить следующие юниты в `~/.config/systemd/user`

 `~/.config/systemd/user/xorg@.socket` 
```
[Unit]
Description=Socket for xorg at display %i

[Socket]
ListenStream=/tmp/.X11-unix/X%i

```
 `~/.config/systemd/user/xorg@.service` 
```
[Unit]
Description=Xorg server at display %i

Requires=xorg@%i.socket
After=xorg@%i.socket

[Service]
Type=simple
SuccessExitStatus=0 1

ExecStart=/usr/bin/Xorg :%i -nolisten tcp -noreset -verbose 2 "vt${XDG_VTNR}"

```

где `${XDG_VTNR`} - виртуальный терминал, на котором будет запущен xorg, либо прописанный в сервисном модуле, либо установленный в среде systemd с помощью

```
$ systemctl --user set-environment XDG_VTNR=1

```

**Note:** xorg должен быть запущен на том же виртуальном терминале, где пользователь вошел в систему. В противном случае logind будет считать сеанс неактивным.

3\. Обязательно настройте переменную среды `DISPLAY`, как описано [выше](#DISPLAY_и_XAUTHORITY).

4\. Затем, чтобы активировать сокет для xorg на дисплее 0 и tty 2, следует выполнить:

```
$ systemctl --user set-environment XDG_VTNR=2     # Так что xorg@.service знает, какой vt использовать
$ systemctl --user start xorg@0.socket            # начинает слушать на сокете для дисплея 0

```

Теперь запуск любого X приложения автоматически запустит xorg на виртуальном терминале 2.

Переменная среды `XDG_VTNR` может быть установлена в среде systemd из `.bash_profile`, а затем можно запустить любое приложение X, включая диспетчер окон, как системный модуль, зависящий от `xorg@0.socket`.

**Важно:** В настоящее время запуск оконного менеджера в качестве пользовательской службы означает, что он работает работает за пределами сеанса, с проблемами, которые могут возникнуть: [break the session](/index.php/General_troubleshooting#Session_permissions "General troubleshooting"). Однако, похоже, что разработчики systemd намерены сделать что-то подобное возможным. Смотрите [[5]](https://mail.gnome.org/archives/desktop-devel-list/2014-January/msg00079.html) и [[6]](http://lists.freedesktop.org/archives/systemd-devel/2014-March/017552.html)

## Некоторые случаи использования

### Постоянный терминальный мультиплексор

Возможно, вы захотите, чтобы в сеансе пользователя по умолчанию использовался терминальный мультиплексор, например [GNU Screen](/index.php/GNU_Screen "GNU Screen") или [Tmux](/index.php/Tmux "Tmux"), в фоновом режиме, а не для входа в сеанс оконного менеджера. Разделение входа в систему от входа в систему X, скорее всего, полезно только для тех, кто загружается с TTY, а не с экранным менеджером (в этом случае вы можете просто связать все, что вы запускаете, с myStuff.target).

Чтобы создать пользовательский сеанс такого типа, действуйте, как указано выше, но вместо создания wm.target создайте multiplexer.target:

```
[Unit]
Description=Terminal multiplexer
Documentation=info:screen man:screen(1) man:tmux(1)
After=cruft.target
Wants=cruft.target

[Install]
Alias=default.target
```

`cruft.target`, как `mystuff.target` выше, должен запускать все, что, по вашему мнению, должно запускаться до запуска tmux или экрана (или что вы хотите запустить при загрузке независимо от времени), например сеанс демона GnuPG.

Затем вам нужно создать сервис для сеанса мультиплексора. Вот пример службы, использующей tmux в качестве примера и использующей сеанс gpg-agent, который записал свою информацию в `/tmp/gpg-agent-info`. Этот пример сеанса при запуске X также сможет запускать программы X, так как установлен DISPLAY.

```
[Unit]
Description=tmux: A terminal multiplixer 
Documentation=man:tmux(1)
After=gpg-agent.service
Wants=gpg-agent.service

[Service]
Type=forking
ExecStart=/usr/bin/tmux start
ExecStop=/usr/bin/tmux kill-server
Environment=DISPLAY=:0
EnvironmentFile=/tmp/gpg-agent-info

[Install]
WantedBy=multiplexer.target
```

Как только это будет сделано, `systemctl --user enable` `tmux.service`, `multiplexer.target` и любые сервисы, которые вы создали для запуска `cruft.target`, и вы должны быть готовы к работе! Активирован `user-session@.service`, как описано выше, но обязательно удалите `Conflicts=getty@tty1.service` из {{ic|user-session@.service} }, поскольку ваш пользовательский сеанс не будет принимать TTY. Поздравляем! У вас есть работающий терминальный мультиплексор и некоторые другие полезные программы, готовые к запуску при загрузке!

### Оконный менеджер

Чтобы запустить Оконный менеджер в качестве службы systemd, сначала необходимо запустить [#Xorg как служба systemd пользователь](#Xorg_как_служба_systemd_пользователь). В следующем примере мы будем использовать awesome:

 `~/.config/systemd/user/awesome.service` 
```
[Unit]
Description=Awesome window manager
After=xorg.target
Requires=xorg.target

[Service]
ExecStart=/usr/bin/awesome
Restart=always
RestartSec=10

[Install]
WantedBy=wm.target

```

**Примечание:** Раздел `[Install]` содержит часть `WantedBy`. При использовании `systemctl --user enable` он будет связывать это как `~/.config/systemd/user/wm.target.wants /*window_manager*.service`, позволяя ему стартовать при входе в систему. Рекомендуется включить этот сервис, а не связывать его вручную.

## Сделать kill процесса при выходе из системы

Arch Linux создает пакет [systemd](https://www.archlinux.org/packages/?name=systemd) с помощью `--without-kill-user-process`, устанавливая `KillUserProcesses` равным `no` по умолчанию. Этот параметр предотвращает уничтожение пользовательских процессов, когда пользователь полностью выходит из системы. Чтобы изменить это поведение и убить все пользовательские процессы при выходе из системы, установите `KillUserProcesses=yes` в `/etc/systemd/logind.conf`.

Обратите внимание, что изменение этого параметра нарушает работу мультиплексоров терминала, таких как [tmux (Русский)](/index.php/Tmux_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Tmux (Русский)") и [GNU Screen (Русский)](/index.php/GNU_Screen_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "GNU Screen (Русский)"). Если вы измените этот параметр, вы все равно сможете использовать терминальный мультиплексор, используя `systemd-run` следующим образом:

```
$ systemd-run --scope --user *command* *args*

```

Например, чтобы запустить `screen`, вы должны сделать:

```
$ systemd-run --scope --user screen -S *foo*

```

## Смотрите также

*   [KaiSforza's Bitbucket wiki](https://bitbucket.org/KaiSforza/systemd-user-units/wiki/Home)
*   [Zoqaeski's units on GitHub](https://github.com/zoqaeski/systemd-user-units)
*   [Arch forum thread about changes in systemd 206 user instances](https://bbs.archlinux.org/viewtopic.php?id=167115)