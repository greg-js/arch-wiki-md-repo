Ссылки по теме

*   [Ключи SSH](/index.php/%D0%9A%D0%BB%D1%8E%D1%87%D0%B8_SSH "Ключи SSH")
*   [Pam abl](/index.php/Pam_abl "Pam abl")
*   [fail2ban (Русский)](/index.php/Fail2ban_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Fail2ban (Русский)")
*   [sshguard](/index.php/Sshguard "Sshguard")
*   [SSHFS (Русский)](/index.php/SSHFS_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "SSHFS (Русский)")
*   [Syslog-ng](/index.php/Syslog-ng "Syslog-ng")
*   [SFTP chroot](/index.php/SFTP_chroot "SFTP chroot")
*   [SCP and SFTP](/index.php/SCP_and_SFTP "SCP and SFTP")
*   [VPN over SSH](/index.php/VPN_over_SSH "VPN over SSH")

**Состояние перевода:** На этой странице представлен перевод статьи [OpenSSH](/index.php/OpenSSH "OpenSSH"). Дата последней синхронизации: 16 января 2020\. Вы можете [помочь](/index.php/ArchWiki_Translation_Team_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "ArchWiki Translation Team (Русский)") синхронизировать перевод, если в английской версии произошли [изменения](https://wiki.archlinux.org/index.php?title=OpenSSH&diff=0&oldid=594953).

[OpenSSH](https://en.wikipedia.org/wiki/ru:OpenSSH "wikipedia:ru:OpenSSH") (OpenBSD Secure Shell) — набор программ, предоставляющих шифрование сеансов связи в компьютерных сетях по протоколу SSH ([Secure Shell](/index.php/Secure_Shell "Secure Shell")). OpenSSH разработан в рамках возглавляемого Тео де Раадтом (Theo de Raadt) проекта [OpenBSD](https://en.wikipedia.org/wiki/ru:OpenBSD "wikipedia:ru:OpenBSD") как открытая альтернатива проприетарному Secure Shell компании SSH Communications Security.

OpenSSH иногда путают с [OpenSSL](https://en.wikipedia.org/wiki/ru:OpenSSL "wikipedia:ru:OpenSSL"); они разрабатываются разными командами и имеют различное назначение. Определённая схожесть в названиях возникла из-за приверженности обоих проектов принципам открытого программного обеспечения (open software).

<input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none">

## Contents

<label class="toctogglelabel" for="toctogglecheckbox"></label>

*   [1 Установка](#Установка)
*   [2 Клиент](#Клиент)
    *   [2.1 Настройка](#Настройка)
*   [3 Сервер](#Сервер)
    *   [3.1 Настройка](#Настройка_2)
    *   [3.2 Демон](#Демон)
    *   [3.3 Безопасность](#Безопасность)
        *   [3.3.1 Отключение ненадёжных алгоритмов и шифров](#Отключение_ненадёжных_алгоритмов_и_шифров)
        *   [3.3.2 Вход только по открытому ключу](#Вход_только_по_открытому_ключу)
        *   [3.3.3 Двухфакторная аутентификация и открытые ключи](#Двухфакторная_аутентификация_и_открытые_ключи)
        *   [3.3.4 Защита от атак полным перебором](#Защита_от_атак_полным_перебором)
            *   [3.3.4.1 Используя ufw](#Используя_ufw)
            *   [3.3.4.2 Используя iptables](#Используя_iptables)
            *   [3.3.4.3 Утилиты для защиты](#Утилиты_для_защиты)
        *   [3.3.5 Ограничение входа от имени суперпользователя](#Ограничение_входа_от_имени_суперпользователя)
            *   [3.3.5.1 Отключение](#Отключение)
            *   [3.3.5.2 Ограничение](#Ограничение)
        *   [3.3.6 Защита файла authorized_keys](#Защита_файла_authorized_keys)
*   [4 Советы и рекомендации](#Советы_и_рекомендации)
    *   [4.1 Шифрованный туннель SOCKS](#Шифрованный_туннель_SOCKS)
        *   [4.1.1 Шаг 1: установить соединение](#Шаг_1:_установить_соединение)
        *   [4.1.2 Шаг 2 (вариант А): настроить браузер (или другие программы)](#Шаг_2_(вариант_А):_настроить_браузер_(или_другие_программы))
        *   [4.1.3 Шаг 2 (вариант Б): настроить TUN-интерфейс](#Шаг_2_(вариант_Б):_настроить_TUN-интерфейс)
    *   [4.2 Проброс X11](#Проброс_X11)
        *   [4.2.1 Настройка](#Настройка_3)
        *   [4.2.2 Использование](#Использование)
    *   [4.3 Проброс других портов](#Проброс_других_портов)
    *   [4.4 Jump-хост](#Jump-хост)
    *   [4.5 Обратный SSH через промежуточный узел](#Обратный_SSH_через_промежуточный_узел)
    *   [4.6 Мультиплексирование](#Мультиплексирование)
    *   [4.7 Увеличение скорости SSH](#Увеличение_скорости_SSH)
    *   [4.8 Монтирование удалённых файловых систем при помощи SSHFS](#Монтирование_удалённых_файловых_систем_при_помощи_SSHFS)
    *   [4.9 Поддержание подключения](#Поддержание_подключения)
    *   [4.10 Автоматический перезапуск туннелей SSH с помощью systemd](#Автоматический_перезапуск_туннелей_SSH_с_помощью_systemd)
    *   [4.11 Autossh - автоматический перезапуск сессий и туннелей SSH](#Autossh_-_автоматический_перезапуск_сессий_и_туннелей_SSH)
        *   [4.11.1 Автозапуск Autossh при загрузке системы при помощи systemd](#Автозапуск_Autossh_при_загрузке_системы_при_помощи_systemd)
    *   [4.12 Альтернатива на случай невозможности запустить демон SSH](#Альтернатива_на_случай_невозможности_запустить_демон_SSH)
    *   [4.13 Настройка цвета фона терминала для удалённого хоста](#Настройка_цвета_фона_терминала_для_удалённого_хоста)
    *   [4.14 Настройка для работы в конкретной сети](#Настройка_для_работы_в_конкретной_сети)
    *   [4.15 Проверка ключей хостов в локальных сетях](#Проверка_ключей_хостов_в_локальных_сетях)
    *   [4.16 Выполнение команд во время входа](#Выполнение_команд_во_время_входа)
*   [5 Решение проблем](#Решение_проблем)
    *   [5.1 Проверка](#Проверка)
    *   [5.2 Подключение отклонено или проблема тайм-аута](#Подключение_отклонено_или_проблема_тайм-аута)
        *   [5.2.1 Проброс портов](#Проброс_портов)
        *   [5.2.2 SSH запущен и прослушивает?](#SSH_запущен_и_прослушивает?)
        *   [5.2.3 Имеются ли правила фаервола, блокирующие соединения?](#Имеются_ли_правила_фаервола,_блокирующие_соединения?)
        *   [5.2.4 Трафик доходит до вашего компьютера?](#Трафик_доходит_до_вашего_компьютера?)
        *   [5.2.5 Ваш провайдер или кто-то еще блокирует нужный порт?](#Ваш_провайдер_или_кто-то_еще_блокирует_нужный_порт?)
            *   [5.2.5.1 Диагностика](#Диагностика)
            *   [5.2.5.2 Возможное решение](#Возможное_решение)
        *   [5.2.6 Read from socket failed: connection reset by peer](#Read_from_socket_failed:_connection_reset_by_peer)
    *   [5.3 "[ваша командная оболочка]: No such file or directory" / ssh_exchange_identification problem](#"[ваша_командная_оболочка]:_No_such_file_or_directory"_/_ssh_exchange_identification_problem)
    *   [5.4 Ошибки "Terminal unknown" и "Error opening terminal"](#Ошибки_"Terminal_unknown"_и_"Error_opening_terminal")
        *   [5.4.1 Хак $TERM](#Хак_$TERM)
    *   [5.5 Ошибка Connection closed by x.x.x.x [preauth]](#Ошибка_Connection_closed_by_x.x.x.x_[preauth])
    *   [5.6 id_dsa не используется в OpenSSH 7.0](#id_dsa_не_используется_в_OpenSSH_7.0)
    *   [5.7 Не удаётся подобрать способ обмена ключами в OpenSSH 7.0](#Не_удаётся_подобрать_способ_обмена_ключами_в_OpenSSH_7.0)
    *   [5.8 Сеанс tmux/screen прерывается при разрыве соединения SSH](#Сеанс_tmux/screen_прерывается_при_разрыве_соединения_SSH)
    *   [5.9 Сеанс SSH не отвечает](#Сеанс_SSH_не_отвечает)
    *   [5.10 Broken pipe](#Broken_pipe)
    *   [5.11 Демон медленно запускается после перезагрузки](#Демон_медленно_запускается_после_перезагрузки)
*   [6 Смотрите также](#Смотрите_также)

## Установка

[Установите](/index.php/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B5 "Установите") пакет [openssh](https://www.archlinux.org/packages/?name=openssh).

## Клиент

Чтобы установить соединение с сервером, выполните:

```
$ ssh -p *порт* *пользователь*@*адрес-сервера*

```

Если на сервере разрешена аутентификация только по открытому ключу, см. [Ключи SSH](/index.php/%D0%9A%D0%BB%D1%8E%D1%87%D0%B8_SSH "Ключи SSH").

### Настройка

Настройки клиента делятся на две категории: общие для всех исходящих соединений и относящиеся к соединениям только с определёнными хостами. Например:

 `~/.ssh/config` 
```
# глобальные настройки
User *пользователь*

# настройки отдельного хоста
Host *мой-сервер*
    HostName *адрес-сервера*
    Port     *порт*

```

С такими настройками следующие команды будут иметь одинаковый эффект:

```
$ ssh -p *порт* *пользователь*@*адрес-сервера*
$ ssh *мой-сервер*

```

Подробнее см. руководство [ssh_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh_config.5).

Некоторые настройки не имеют флагов-аналогов для командной строки, но можно указать необходимые опции с помощью флага `-o`. Например, `-oKexAlgorithms=+diffie-hellman-group1-sha1`.

## Сервер

`sshd` — демон сервера OpenSSH, который управляется службой `sshd.service` в соответствии с настройками в файле `/etc/ssh/sshd_config`. Если вы собираетесь изменить настройки, то стоит сначала запустить `sshd` в тестовом режиме, чтобы убедиться, что демон запустится без проблем. Отсутствие вывода означает рабочую конфигурацию.

```
# sshd -t

```

### Настройка

Чтобы изменить настройки, нужно отредактировать/добавить нужные строки в файле настроек, например:

Предоставить доступ отдельным пользователям:

```
AllowUsers    *пользователь1 пользователь2*

```

Предоставить доступ группам пользователей:

```
AllowGroups   *группа1 группа2*

```

Параметр `Banner` позволяет настроить приветственное сообщение (например, сохранённое в файле `/etc/issue`):

```
Banner /etc/issue

```

Пары открытых и закрытых ключей генерируются [демоном sshd](#Демон) при первом запуске и сохраняются в каталог `/etc/ssh`. Создаётся четыре пары ключей на основе алгоритмов [dsa, rsa, ecdsa и ed25519](/index.php/SSH_keys_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Выбор_типа_шифрования "SSH keys (Русский)"). Чтобы sshd использовал какой-то определённый ключ, укажите следующую опцию:

```
HostKey /etc/ssh/ssh_host_rsa_key

```

Если сервер находится в глобальной (WAN) сети, рекомендуется также сменить порт со стандартного 22 на случайное значение, например:

```
Port 39901

```

**Совет:**

*   Альтернативный порт лучше выбирать из числа не занятых другими службами. Инфомацию о портах можно найти в файле `/etc/services`, а также в статье [Список портов TCP и UDP](https://en.wikipedia.org/wiki/ru:%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BF%D0%BE%D1%80%D1%82%D0%BE%D0%B2_TCP_%D0%B8_UDP "wikipedia:ru:Список портов TCP и UDP"). Смена порта снизит количество попыток входа, выполняемых автоматизированными сканерами и скриптами, которые обычно ожидают SSH-соединение на порте 22\. Чтобы полностью исключить такие попытки, можно настроить [port knocking](/index.php/Port_knocking "Port knocking").
*   В целях безопасности рекомендуется полностью [отключить вход по паролю](#Вход_только_по_открытому_ключу). Другие полезные способы повышения защищённости SSH-соединения описаны в разделе [#Безопасность](#Безопасность).
*   OpenSSH может прослушивать несколько портов одновременно. Для этого укажите несколько параметров `Port *номер-порта*` в файле настроек.
*   Можно сгенерировать новые пары ключей в дополнение (или взамен) к тем, которые были созданы изначально. Подробнее см. [SSH keys (Русский)#Генерация пары ключей SSH](/index.php/SSH_keys_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Генерация_пары_ключей_SSH "SSH keys (Русский)").

### Демон

[Запустите/включите](/index.php/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5/%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5 "Запустите/включите") службу `sshd.service`. Демон SSH будет работать в фоновом режиме и выполнять форк (fork) для каждого входящего соединения [[1]](https://projects.archlinux.org/svntogit/packages.git/tree/trunk/sshd.service?h=packages/openssh).

**Примечание:** `sshd.socket` был удалён из [openssh](https://www.archlinux.org/packages/?name=openssh) в версии 8.0p1-3\. Он использовал активацию сокета systemd, вследствие чего оказался уязвим к DoS-атакам (см. [FS#62248](https://bugs.archlinux.org/task/62248)). Если `sshd.socket` будет включён во время обновления до [openssh](https://www.archlinux.org/packages/?name=openssh) 8.0p1-3, то юниты `sshd.socket` и `sshd@.service` будут скопированы в каталог `/etc/systed/system` и [снова включены](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Замена_файлов_юнита "Systemd (Русский)"). Это сделано с единственной целью — не поломать существующие конфигурации, в остальном же рекомендуется перейти на использование `sshd.service`.

**Важно:** Если вы продолжаете использовать `sshd.socket`, обратите внимание на следующие моменты:

*   Юнит `sshd.socket` может внезапно прекратить работу (например, из-за исчерпания свободной памяти), а опцию `Restart=always` для юнитов сокетов задать нельзя [[2]](https://github.com/systemd/systemd/issues/11553).
*   Использовании активации сокета может привести к отказу в обслуживании (denial of service), если слишком большое количество соединений приведёт к невозможности новых запусков службы (см. [FS#62248](https://bugs.archlinux.org/task/62248)).

**Примечание:** Для `sshd.socket` нельзя задать параметр `ListenAddress`, поэтому будут разрешены соединения с любых адресов. Для создания аналогичной `ListenAddress` настройки [отредактируйте](/index.php/%D0%9E%D1%82%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D1%83%D0%B9%D1%82%D0%B5 "Отредактируйте") файл `sshd.socket`, указав порт и IP-адрес в параметре `ListenStream` (например, `ListenStream=192.168.1.100:22`). Также нужно добавить параметр `FreeBind=true` в раздел `[Socket]`, иначе проявится та же проблема, что и при задании `ListenAddress`: если сеть не успела вовремя включиться, сокет не запустится.

**Совет:** При использовании активации сокета для каждого соединения создаётся временный экземпляр `sshd@.service` (каждый со своим названием). Следовательно, ни `sshd.socket`, ни обычный `sshd.service` не будут логировать попытки установления соединения. Логи экземпляров сокетов можно просматривать командами `journalctl -u "sshd@*"` и `journalctl /usr/bin/sshd`.

### Безопасность

Удалённый вход в систему через SSH удобен для осуществления административных задач, но представляет определённую проблему с точки зрения безопаности. SSH часто подвергается атакам полным перебором и нуждается в соответствующей конфигурации, чтобы не дать посторонним войти в систему.

Следующие статьи и инструменты могут также быть полезными:

*   [Статья Mozilla Infosec Team](https://wiki.mozilla.org/Security/Guidelines/OpenSSH "mozillawiki:Security/Guidelines/OpenSSH")
*   [Утилита ssh_scan](https://github.com/mozilla/ssh_scan)
*   [Безопасный SSH](https://stribika.github.io/2015/01/04/secure-secure-shell.html)

#### Отключение ненадёжных алгоритмов и шифров

Настройки по умолчанию позволяют использовать алгоритмы и шифры, которые на данный момент известны как ненадёжные. Это сделано для обеспечения обратной совместимости с legacy-клиентами. Если поддержка старых версий клиента в ваши планы не входит, то ненадёжные настройки лучше отключить. Ниже представлен пример файла настроек `/etc/ssh/sshd_config`.

Алгоритмы представлены в виде списка. При установлении соединения клиент сравнит свой список поддерживаемых методов шифрования с алгоритмами сервера и выберет первый подходящий. Списки составлены в порядке убывания надёжности в соответствии с рекомендациями разработчиков OpenSSH на момент выхода версии 8.1 в октябре 2019 года. Ненужные пункты в конце каждого списка при желании можно удалить.

 `/etc/ssh/sshd_config` 
```
KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group14-sha256,diffie-hellman-group14-sha1

MACs umac-64-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha1-etm@openssh.com,umac-64@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512,hmac-sha1

HostKeyAlgorithms ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384-cert-v01@openssh.com,ecdsa-sha2-nistp521-cert-v01@openssh.com,ssh-ed25519-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com,rsa-sha2-256-cert-v01@openssh.com,ssh-rsa-cert-v01@openssh.com,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-ed25519,rsa-sha2-512,rsa-sha2-256,ssh-rsa

```

Кроме того, см. [ssh-audit](https://aur.archlinux.org/packages/ssh-audit/).

#### Вход только по открытому ключу

Если клиент не может выполнить вход по открытому ключу, SSH-сервер по умолчанию предоставляет возможность аутентификации по паролю. Это позволяет злоумышленнику получить доступ с помощью [полного перебора](#Защита_от_атак_полным_перебором) паролей. Самый надёжный способ защиты от такой атаки — полностью отключить вход по паролю и оставить только аутентификацию с помощью [ключей SSH](/index.php/SSH_keys_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "SSH keys (Русский)"). Для этого нужно отключить следующую опцию в файле настроек демона:

 `/etc/ssh/sshd_config`  `PasswordAuthentication no` 
**Важно:** Перед заданием этой настройки следует убедиться, что аутентификация по открытому ключу включена для всех аккаунтов, которым может потребоваться SSH-доступ. Для этого используются файлы `authorized_keys`. Подробнее см. [SSH keys (Русский)#Копирование открытого ключа на удалённый сервер](/index.php/SSH_keys_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Копирование_открытого_ключа_на_удалённый_сервер "SSH keys (Русский)").

#### Двухфакторная аутентификация и открытые ключи

С помощью опции `AuthenticationMethods` можно настроить использование различных способов аутентификации, например, применение открытых ключей совместно с двухфакторной аутентификацией.

В статье [Google Authenticator](/index.php/Google_Authenticator "Google Authenticator") описана настройка Google Authenticator.

Для использования [PAM](/index.php/PAM "PAM") с OpenSSH, отредактируйте следующий файл:

 `/etc/ssh/sshd_config` 
```
ChallengeResponseAuthentication yes
AuthenticationMethods publickey keyboard-interactive:pam

```

После этого можно будет выполнять вход в систему или по открытому ключу, **или** в соответствии настройками аутентификации PAM.

Наоборот, если вы хотите настроить вход по открытому ключу **и** через PAM, используйте в качестве разделителя AuthenticationMethods запятую, а не пробел:

 `/etc/ssh/sshd_config` 
```
ChallengeResponseAuthentication yes
AuthenticationMethods publickey**,**keyboard-interactive:pam

```

При входе по ключу и PAM аутентификацию по паролю можно отключить:

 `/etc/pam.d/sshd` 
```
#отключение удалённного root
auth      required  pam_securetty.so

#требуется google authenticator
auth      required  pam_google_authenticator.so

#но пароль не нужен
#auth      include   system-remote-login
account   include   system-remote-login
password  include   system-remote-login
session   include   system-remote-login

```

#### Защита от атак полным перебором

Принцип атаки полным перебором прост: атакующий многократно пытается выполнить вход на страницу или веб-сервер, используя большое количество случайных комбинаций имён пользователей и паролей.

##### Используя ufw

См. [ufw#Rate limiting with ufw](/index.php/Ufw#Rate_limiting_with_ufw "Ufw").

##### Используя iptables

Если вы используете межсетевой экран iptables, то можно создать правила для защиты SSH от атаки перебором.

**Примечание:** В этом примере для SSH выбран TCP-порт 42660.

Создаём новую цепочку для обнаружения чрезмерного количества попыток входа и занесения их в лог:

```
# iptables -N LOG_AND_DROP

```

Первое правило будет обрабатывать пакеты, которые указывают на создание нового соединения на порте 42660:

```
# iptables -A INPUT -p tcp -m tcp --dport 42660 -m state --state NEW -m recent --set --name DEFAULT --rsource

```

Затем iptables будет отслеживать пакеты, которые совпадают с предыдущим правилом либо пришли от хоста, уже находящегося в списке наблюдения:

```
# iptables -A INPUT -p tcp -m tcp --dport 42660 -m state --state NEW -m recent --update --seconds 90 --hitcount 4 --name DEFAULT --rsource -j LOG_AND_DROP

```

Правило для TCP-трафика на порте 42660, не отфильтрованного предыдущим:

```
# iptables -A INPUT -p tcp -m tcp --dport 42660 -j ACCEPT

```

Присоединяем правило к таблице LOG_AND_DROP и используем оператор -j (jump) для передачи информации подсистеме логирования:

```
# iptables -A LOG_AND_DROP -j LOG --log-prefix "iptables deny: " --log-level 7

```

После занесения информации в логи пакеты будут уничтожены:

```
# iptables -A LOG_AND_DROP -j DROP

```

##### Утилиты для защиты

Автоматизированные программы вроде [fail2ban](/index.php/Fail2ban_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Fail2ban (Русский)") или [sshguard](/index.php/Sshguard "Sshguard") помогают защититься от атак перебором, блокируя попытки подобрать пароли.

*   Разрешайте входящие SSH-соединения только для доверенных адресов
*   Используйте [fail2ban](/index.php/Fail2ban_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Fail2ban (Русский)") или [sshguard](/index.php/Sshguard "Sshguard") для автоматической блокировки IP-адресов, которые провалили попытку аутентификации слишком много раз.
*   Используйте [pam_shield](https://github.com/jtniehof/pam_shield) для блокировки IP-адресов, которые выполняют слишком большое количество попыток входа за определённый период времени. В отличие от [fail2ban](/index.php/Fail2ban_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Fail2ban (Русский)") и [sshguard](/index.php/Sshguard "Sshguard"), pam_shield не различает успешными и неудачными попытками входа.

#### Ограничение входа от имени суперпользователя

Предоставление возможности входа через SSH от имени суперпользователя без какой-либо защиты считается плохой практикой. Существует два способа ограничения этой возможности для повышения безопасности.

##### Отключение

Утилита [sudo](/index.php/Sudo_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Sudo (Русский)") выборочно предоставляет права суперпользователя для действий, которым они необходимы, без входа в учётную запись root. Благодаря этому можно заблокировать аккаунт root, чтобы отключить возможность входа в него через SSH. Это потенциально является средством защиты от атак перебором, поскольку атакующему придётся подбирать ещё и имя учётной записи в дополнение к паролю.

Чтобы отключить вход от имени суперпользователя через SSH, получите его права и отредактируйте секцию "Authentication" файла `/etc/ssh/sshd_config`. Просто измените значение `#PermitRootLogin yes` на `no` и раскомментируйте строку:

 `/etc/ssh/sshd_config` 
```
PermitRootLogin no
...

```

[Перезапустите](/index.php/%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5 "Перезапустите") демон SSH.

Теперь вы не сможете войти в систему через SSH от имени суперпользователя, но по-прежнему будете иметь возможность входить от имени обычного пользователя и использовать команды [su](/index.php/Su "Su") и [sudo](/index.php/Sudo_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Sudo (Русский)") для администрирования.

##### Ограничение

Некоторые автоматические задачи, вроде удалённого резервного копирования системы, требуют полного root-доступа. Чтобы иметь возможность безопасно его использовать, вместо отключения укажите конкретные команды. Для этого отредактируйте файл `~root/.ssh/authorized_keys`, создав префиксы для соответствующих ключей, например:

```
command="/usr/lib/rsync/rrsync -ro /" ssh-rsa …

```

Теперь при входе с использованием соответствующего ключа пользователь получит права root, но сможет выполнять только те команды, которые перечислены между кавычками.

При этом остаётся возможность входа в систему с использованием имени суперпользователя. Это можно исправить, добавив следующую строку в файл `sshd_config`:

```
PermitRootLogin forced-commands-only

```

Это не только ограничит список команд, которые могут выполняться через SSH от имени суперпользователя, но и отключит использование паролей, оставляя возможность входа в root-аккаунт только по ключу.

Есть альтернатива, вводящая меньше ограничений, которая позволит выполнять любые команды от имени суперпользователя, но сделает невозможной атаку перебором благодаря отключению входа по паролю. Для этого пропишите:

```
PermitRootLogin prohibit-password

```

#### Защита файла authorized_keys

Для дополнительной защиты можно запретить пользователям добавлять новые открытые ключи, по которым можно будет выполнить соединение.

Задайте файлу `authorized_keys` права только на чтение для владельца и отключите остальные:

```
$ chmod 400 ~/.ssh/authorized_keys

```

Чтобы не позволить пользователям вернуть разрешения, установите [бит неизменяемости](/index.php/File_permissions_and_attributes#chattr_and_lsattr "File permissions and attributes") на файл `authorized_keys`. После этого пользователь может попытаться перемеименовать каталог `~/.ssh` и создать новый каталог с таким же именем и файлом `authorized_keys`. Чтобы не дать ему это сделать, установите бит неизменяемости и на каталог `~/.ssh`.

**Примечание:** Если понадобится добавить новый ключ, то придётся удалить бит неизменяемости файла `authorized_keys` и дать ему права на запись. В конце нужно будет вернуть настройки обратно.

## Советы и рекомендации

### Шифрованный туннель SOCKS

Эта возможность будет полезна для обладателей ноутбуков, которые часто подключаются к небезопасным беспроводным сетям в общественных местах. Для создания туннеля необходимо предварительно запустить сервер SSH в каком-нибудь безопасном месте, например, дома или на работе. Также будет весьма кстати какая-нибудь служба динамического DNS вроде [DynDNS](https://dyn.com/dns/), которая избавит вас от необходимости запоминать IP-адрес.

#### Шаг 1: установить соединение

Для установления соединения необходимо лишь выполнить команду:

```
$ ssh -TND 4711 *пользователь*@*хост*

```

где `*пользователь*` — ваше имя пользователя на сервере SSH, работающием на машине `*хост*`. Сервер запросит пароль, после чего будет установлено соединение. Флаг `N` отключает интерактивное приглашение командной строки, а флаг `D` позволяет пользователю выбрать локальный порт для прослушивания. Флаг `T` означает, что сервер не станет выделять псевдо-терминал для данного соединения.

Также стоит указать флаг `-v`, который сделает вывод команды более многословным. В частности, по выводу можно будет понять, что соединение действительно было установлено.

#### Шаг 2 (вариант А): настроить браузер (или другие программы)

Чтобы установленное соединение (см. выше) было хоть как-то полезно, нужно настроить браузер и другие программы на использование туннеля SOCKS. В настоящее время SSH поддерживает как SOCKSv4, так и SOCKSv5, вы можете выбрать любой из них.

*   Для Firefox: *Preferences > General > Settings...*. В открывшемся окне выберите пункт *Manual proxy configuration*, введите `localhost` в поле *SOCKS host* и номер порта в поле *Port* (`4711` для примера выше).

	DNS-запросы Firefox автоматически посылаться через туннель не будут, что представляет собой некоторую уязвимость с точки зрения приватности. Чтобы это исправить, также выберите пункт *Proxy DNS when using SOCKS v5*. Очевидно, что это будет работать, только если вы выбрали пятую версию протокола SOCKS, а не четвёртую.

	Перезапустите Firefox, чтобы настройки заработали.

*   Для Chromium: SOCKS можно настроить через переменные окружения или опции командной строки. Например, выберите одну из следующих функций и добавьте её в файл `.bashrc`:

```
function secure_chromium {
    port=4711
    export SOCKS_SERVER=localhost:$port
    export SOCKS_VERSION=5
    chromium &
    exit
}

```

или

```
function secure_chromium {
    port=4711
    chromium --proxy-server="socks://localhost:$port" &
    exit
}

```

Теперь откройте терминал, выполните

```
$ secure_chromium

```

и наслаждайтесь защищённым туннелем!

#### Шаг 2 (вариант Б): настроить TUN-интерфейс

Этот вариант выглядит несколько более запутанным по сравнению с предыдущим, но зато вам не придётся настраивать работу через SOCKS-прокси для каждого приложения по отдельности. Данное решение подразумевает настройку локального TUN-интерфейса и перенаправление всего трафика на него.

Подробнее см. [VPN over SSH#Set up badvpn and tunnel interface](/index.php/VPN_over_SSH#Set_up_badvpn_and_tunnel_interface "VPN over SSH").

### Проброс X11

Проброс Х11 — механизм, который позволяет графическим интерфейсам программ удаленной машины-сервера отображаться на локальной машине-клиенте. При этом нет необходимости устанавливать на удаленном узле всю систему Х11, но надо установить хотя бы *xauth*. *xauth* — утилита, которая поддерживает конфигурации `Xauthority`, используемые сервером и клиентом для аутентификации сессии X11 [[4]](http://xmodulo.com/2012/11/how-to-enable-x11-forwarding-using-ssh.html).

**Важно:** Использование проброса X11 имеет важные последствия для безопасности. Изучите соответствующие разделы страниц справочных руководств [ssh(1)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh.1), [sshd_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/sshd_config.5) и [ssh_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh_config.5), а также [вопрос на StackExchange](https://security.stackexchange.com/questions/14815/security-concerns-with-x11-forwarding)

#### Настройка

На удалённой системе:

*   [Установите](/index.php/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B5 "Установите") пакеты [xorg-xauth](https://www.archlinux.org/packages/?name=xorg-xauth) и [xorg-xhost](https://www.archlinux.org/packages/?name=xorg-xhost);
*   В файле `/etc/ssh/ssh**d**_config`:
    *   Задайте для опции `X11Forwarding` значение `yes`;
    *   Убедитесь, что заданы значения `AllowTcpForwarding yes`, `X11UseLocalhost yes` и `X11DisplayOffset 10` (значения по умолчанию, если ничего не менялось, см. [sshd_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/sshd_config.5));
*   [Перезапустите](/index.php/%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5 "Перезапустите") [#Демон](#Демон) *sshd*.

На клиенте:

*   [Установите](/index.php/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B5 "Установите") пакет [xorg-xauth](https://www.archlinux.org/packages/?name=xorg-xauth);
*   включите опцию `ForwardX11` либо добавив флаг `-X` в командной строке, либо задав в [файле настроек клиента](#Клиент) параметр `ForwardX11 yes`.

**Совет:** Если графический интерфейс отображается плохо или вы получаете сообщения об ошибках, включите опцию `ForwardX11Trusted` (в командной строке это флаг `-Y`). Это предотвратит управление пробросом Х11 со стороны [расширения безопасности X11](http://www.x.org/wiki/Development/Documentation/Security/). Если вы будете использовать эту опцию, обязательно прочитайте [предупреждение](#Проброс_X11) в начале этого раздела

#### Использование

Выполните удалённый вход как обычно, добавив флаг `-X`, если опция *ForwardX11* не включена в конфигурационном файле клиента:

```
$ ssh -X *пользователь*@*хост*

```

Если вы получаете ошибки при запуске графических приложений, попробуйте опцию *ForwardX11Trusted*:

```
$ ssh -Y *пользователь*@*хост*

```

Теперь вы можете запустить любую программу с графическим интерфейсом пользователя на удаленном сервере, и ее вывод будет перенаправлен в вашу локальную сессию:

```
$ xclock

```

Если вы получите ошибки "Cannot open display", попробуйте выполнить следующую команду от имени обычного пользователя:

```
$ xhost +

```

эта команда позволит выполнять проброс приложений X11 любому пользователю. Чтобы ограничить проброс конкретным хостом:

```
$ xhost +*имя-хоста*

```

где *имя-хоста* - это имя конкретного хоста. Подробнее см. [xhost(1)](https://jlk.fjfi.cvut.cz/arch/manpages/man/xhost.1).

Будьте осторожны с некоторыми приложениями, так как они могут проверять локальную машину на предмет уже работающего приложения. Один из примеров - [Firefox](/index.php/Firefox_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Firefox (Русский)"): либо закройте работающий Firefox, либо используйте следующий параметр запуска:

```
$ firefox --no-remote

```

Если вы получите ошибку `X11 forwarding request failed on channel 0` при подключении (и лог-файл сервера `/var/log/errors.log` будет содержать строку `Failed to allocate internet-domain X11 display socket`), удостоверьтесь, что пакет [xorg-xauth](https://www.archlinux.org/packages/?name=xorg-xauth) установлен. Если его установка не поможет, попробуйте сделать одно из двух:

*   Включить опцию `AddressFamily any` в файле `ssh**d**_config` на сервере;
*   Задать опции `AddressFamily` в `ssh**d**_config` на сервере значение inet. Присвоение значения inet может исправить проблемы с клиентами Ubuntu при использовании IPv4.

Для запуска приложений X от имени других пользователей на сервере SSH вам необходимо добавить (команда `xauth add`) строку аутентификации, взятую из вывода команды `xauth list` пользователя, вошедшего в систему.

**Совет:** Полезные ссылки при решении проблем с пробросом X11: [[5]](http://unix.stackexchange.com/a/12772/29867), [[6]](http://unix.stackexchange.com/a/46748/29867), [[7]](http://superuser.com/a/805060/185665).

### Проброс других портов

В дополнение к встроенной поддержке SSH X11 также можно установить безопасный туннель для любого соединения TCP с использованием локального или удаленного проброса.

Локальный проброс открывает на локальной машине порт, подключения к которому будут перенаправлены на удаленный хост, а оттуда - по заданному направлению. Очень часто этим направлением будет сам удаленный хост, предоставляющий secure shell и, например, безопасное соединение [VNC](/index.php/VNC "VNC") для этой же машины. Локальный проброс осуществляется при помощи ключа `-L` и задания спецификации проброса в следующей форме: `<порт туннеля>:<адрес назначения>:<порт назначения>`.

Например:

```
$ ssh -L 1000:mail.google.com:25 192.168.0.100

```

будет использовать SSH для входа в систему и открытия шелла на `192.168.0.100`, а также создаст туннель от порта 1000 локальной машины на порт 25 mail.google.com. В результате подключения к `localhost:1000` будут перенаправлены на порт Gmail SMTP. Для Google всё будет выглядеть так, будто соединение (но вовсе не обязательно — передаваемые по нему данные) исходит от `192.168.0.100`; данные будут в безопасности между локальной машиной и `192.168.0.100`, но не между `192.168.0.100` и Google, если не предпринять дополнительных мер.

Также:

```
$ ssh -L 2000:192.168.0.100:6001 192.168.0.100

```

будет принимать подключения к `localhost:2000`, которые будут перенаправлены на порт 6001 удаленного хоста. Этот пример хорош для VNC-соединений с помощью утилиты vncserver. Утилита входит в пакет [TigerVNC](/index.php/TigerVNC "TigerVNC"), и, несмотря на очевидную полезность, имеет некоторые проблемы с безопасностью.

Удаленный проброс позволяет удаленному хосту подключаться к произвольному хосту через туннель SSH и локальную машину, предоставляя функционал, обратный локальному пробросу. Это полезно в ситуациях, когда, например, удаленный хост ограничен фаерволлом. Он включается ключом `-R` и заданием спецификаций проброса в следующей форме: `<порт туннеля>:<адрес назначения>:<порт назначения>`.

Например:

```
$ ssh -R 3000:irc.freenode.net:6667 192.168.0.200

```

поднимет шелл на `192.168.0.200`, и соединения из `192.168.0.200` к своему же порту 3000 (т.е. `localhost:3000` удалённого хоста) будут посланы через туннель на локальную машину, а затем на irc.freenode.net, порт 6667, что в данном примере позволит использовать программы IRC на удаленном хосте, даже если обычно порт 6667 будет для них заблокирован.

Оба вида проброса могут быть использованы для предоставления безопасного "шлюза", позволяющего другим компьютерам получить преимущества туннеля SSH без непосредственно работающего SSH или демона SSH, при использовании bind-адреса в начале туннеля как части спецификации проброса, например, `<адрес туннеля>:<порт туннеля>:<адрес назначения>:<порт назначения>`. `<адрес туннеля>` может быть любым адресом на машине, `localhost`, `*` (или blank), который, соответственно, пропускает соединения через заданный адрес, интерфейс loopback или любой интерфейс. По умолчанию проброс ограничен соединениями от машины в начале туннеля, `<адрес туннеля>` установлен в `localhost`. Локальный проброс не требует дополнительной настройки, в то время как удаленный проброс ограничен конфигурацией демона SSH удаленного сервера. Смотрите описание опции `GatewayPorts` на справочной странице `sshd_config(5)` и опции `-L address` в руководстве [ssh(1)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh.1) для получения дополнительной информации.

### Jump-хост

Может случиться так, что у вас не будет возможности установить связь с удалённой машиной напрямую. В этом случае используется [jump-сервер](https://en.wikipedia.org/wiki/ru:%D0%98%D0%BD%D1%81%D1%82%D0%B0%D0%BB%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80 "wikipedia:ru:Инсталляционный сервер") или [узел-бастион](https://en.wikipedia.org/wiki/ru:Bastion_host "wikipedia:ru:Bastion host"). Следовательно, необходимо соединить два или более SSH-туннеля в цепочку. Разумеется, ваши ключи должны позволять выполнить авторизацию на каждом из серверов в цепи. Для этого SSH запускается с опциями пересылки аутентификационных данных (`-A`) и выделения псевдотерминала (`-t`):

```
$ ssh -A -t -l *пользователь1 бастион1* \
  ssh -A -t -l *пользователь2 промежуточный-узел2* \
  ssh -A -t -l *пользователь3 целевой-узел*

```

Несколько проще то же самое можно сделать с флагом `-J`:

```
$ ssh -J *пользователь1*@*бастион1*,*пользователь2*@*промежуточный-узел2* *пользователь3*@*целевой-узел*

```

Промежуточные хосты в директиве `-J` разделяются запятыми и располагаются в порядке установления соединения. Часть `*пользователь...*@` необязательна. При работе с опцией `-J` используется стандартный файл настроек SSH, поэтому при необходимости в нём можно указать настройки соединения для каждого хоста в отдельности.

Опция `ProxyJump` в файле настроек эквивалентyна флагу командной строки `-J`, см. [ssh_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh_config.5).

### Обратный SSH через промежуточный узел

Идея заключается в том, чтобы подключиться к серверу через промежуточный узел, причём сервер соединяется с этим узлом через обратный SSH-туннель. Например, это может быть полезно, когда сервер находится за NAT, а промежуточный узел представляет собой публичный SSH-сервер, используемый в качестве прокси. При этом:

*   у клиента должны быть ключи для авторизации и на промежуточном узле, и на целевом сервере;
*   у сервера должны быть ключи дла авторизации на промежуточном узле.

Ниже приведён пример настройки соединения через промежуточный узел. Предполагается, что *пользователь1* — аккаунт на клиентской машине, *пользователь2* — на промежуточном узле и *пользователь3* — на сервере. Сначала необходимо создать обратный туннель:

```
ssh -R 2222:localhost:22 -N *пользователь2*@*промежуточный-узел*

```

Это действие можно автоматизировать с помощью скрипта, службы systemd или [autossh](#Autossh_-_автоматический_перезапуск_сессий_и_туннелей_SSH).

Соединение со стороны клиента устанавливается командой:

```
ssh -t *пользователь1*@*промежуточный-узел* ssh *пользователь3*@localhost -p 2222

```

Удалённую команду для создания соединения с обратным туннелем можно добавить в файл `~/.ssh/authorized_keys` на промежуточном узле. Для этого воспользуйтесь полем `command`:

```
command="ssh *пользователь3*@localhost -p 2222" ssh-rsa KEY2 *пользователь1*@*клиент*

```

Тогда установить соединение можно командой:

```
ssh *пользователь2*@*промежуточный-узел*

```

Обратите внимание, что функция автодополнения [SCP](https://en.wikipedia.org/wiki/ru:SCP "wikipedia:ru:SCP") в терминале клиента работать не будет, а на некоторых конфигурациях не будет работать и сама передача данных по протоколу SCP.

### Мультиплексирование

Демон SSH обычно прослушивает порт 22\. Однако трафик, который адресован не на стандартные порты HTTP/S (80 и 443 соответственно), на публичных серверах часто блокируется. Следовательно, в таком случае SSH-соединение невозможно. В качестве возможного решения можно указать демону `sshd` прослушивать один из портов в белом списке:

 `/etc/ssh/sshd_config` 
```
Port 22
Port 443

```

Поскольку порт 443 уже прослушивается веб-сервером в ожидании HTTPS-пакетов, в данном случае имеет смысл воспользоваться мультиплексором вроде [sslh](https://www.archlinux.org/packages/?name=sslh). Он будет прослушивать мультиплексированный порт и переадресовывать пакеты разным сервисам в зависимости от их назначения.

### Увеличение скорости SSH

Среди [настроек клиента](#Настройка) есть некоторые, которые позволяют увеличить скорость соединения либо глобально, либо для отдельных хостов. Полное описание этих опций можно найти в руководстве [ssh_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh_config.5).

*   *Используйте быстрый алгоритм шифрования*: в современных процессорах с инструкциями AESNI алгоритмы `aes128-gcm@openssh.com` и `aes256-gcm@openssh.com` гораздо более производительны, чем стандартный алгоритм OpenSSH, `chacha20-poly1305@openssh.com`. Выбрать алгоритм можно флагом `-c`. Чтобы сделать изменения постоянными, добавьте пункт `Ciphers` в файл `~/.ssh/config`, перечислив алгоритмы в порядке уменьшения предпочтительности, например:

    	 `Ciphers aes128-gcm@openssh.com,aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr` 

*   *Включите или выключите сжатие*: сжатие может увеличить скорость для медленных соединений, оно включается параметром `Compression yes` или флагом `-C`. Однако в качестве алгоритма сжатия используется относительно медленный [gzip(1)](https://jlk.fjfi.cvut.cz/arch/manpages/man/gzip.1), который в быстрых сетях становится узким местом. Поэтому в локальных и быстрых сетях лучше отключить сжатие параметром `Compression no`.

*   *Объединение соединений*: в случае нескольких одновременных сессий к одному хосту можно объединить их в одно соединение:

    ```
    ControlMaster auto
    ControlPersist yes
    ControlPath ~/.ssh/sockets/socket-%r@%h:%p

    ```

	где вместо `~/.ssh/sockets` можно использовать любой каталог без прав на запись для остальных пользователей.

*   Параметр `ControlPersist` позволяет задать время ожидания после момента разрыва исходного соединения. Возможны следующие значения:
    *   `no` — соединение разрывается сразу же после отключения предыдущего клиента;
    *   время ожидания в секундах;
    *   `yes` — бесконечное ожидание, соединение автоматически разрываться не будет.

*   Время входа можно сократить, если пропустить поиск заголовков IPv6\. Для этого используйте опции `AddressFamily inet` или флаг `-4`.

*   Наконец, если вы собираетесь использовать SSH для SFTP или SCP, [High Performance SSH/SCP](https://www.psc.edu/index.php/hpn-ssh) поможет значительно увеличить пропускную способность с помощью динамического изменения размера буфера SSH. Установите пакет [openssh-hpn-git](https://aur.archlinux.org/packages/openssh-hpn-git/), чтобы использовать OpenSSH с этим расширением.

### Монтирование удалённых файловых систем при помощи SSHFS

В статье [SSHFS](/index.php/SSHFS "SSHFS") описано, как использовать SSH для монтирования удалённых файловых систем в локальный каталог, чтобы иметь возможность выполнять любые операции над смонтированными файлами (копирование, переименование, редактирование в vim и т.д.). Предпочтительнее использовать *sshfs*, а не *shfs*, поскольку последний не обновлялся с 2004 года.

### Поддержание подключения

По умолчанию сеанс связи SSH автоматически разрывается, если соединение не использовалось в течение какого-то времени. Чтобы сохранить сеанс, клиент может посылать сигналы серверу, если не было получено никаких данных за последнее время, или наоборот, сервер может посылать сообщения через определённые временные интервалы, если он не получал данных от клиента.

*   На **сервере** параметр `ClientAliveInterval` задаёт время ожидания в секундах, по истечении которого при отсутствии данных от клиента *sshd* пошлёт последнему запрос. Значение по умолчанию — 0, "не посылать сообщений". Например, чтобы запрашивать ответ от клиента каждые 60 секунд, задайте параметр `ClientAliveInterval 60` в [настройках сервера](#Настройка_2). Также обратите внимание на параметры `ClientAliveCountMax` и `TCPKeepAlive`.
*   На **клиенте** параметр `ServerAliveInterval` задаёт временной промежуток между запросами на сервер. Например, чтобы посылать запросы каждые 120 секунд, задайте параметр `ServerAliveInterval 120` в [настройках клиента](#Настройка). Также обратите внимание на параметры `ServerAliveCountMax` и `TCPKeepAlive`.

**Примечание:** Чтобы сохранять соединение, достаточно настоить отправку запросов либо только на клиенте, либо только на сервере. Если вы под вашим управлением находится одновременно несколько серверов и клиентов, правильнее всего будет задать параметр `ServerAliveInterval` на клиентах, которым нужно сохранять сеансы, а настройки серверов и остальных клиентов оставить без изменений.

### Автоматический перезапуск туннелей SSH с помощью systemd

[systemd](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Systemd (Русский)") может автоматически создавать SSH-соединения при загрузке/входе в систему, а также перезапускать их при внезапном разрыве соединения.

Ниже представлен пример службы, которая будет создавать SSH-туннель в соответствии с [настройками SSH](#Настройка). Если соединение было по какой-то причине разорвано, служба подождёт 10 секунд и перезапустит его:

 `~/.config/systemd/user/tunnel.service` 
```
[Unit]
Description=SSH tunnel to myserver

[Service]
Type=simple
Restart=always
RestartSec=10
ExecStart=/usr/bin/ssh -F %h/.ssh/config -N myserver

```

[запустите/включите](/index.php/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5/%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5 "Запустите/включите") [пользовательскую службу](/index.php/Systemd/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C "Systemd/Пользователь") systemd. В разделе [#Поддержание подключения](#Поддержание_подключения) описано, как предотвратить разрыв соединения из-за превышения времени ожидания. Если вы захотите запускать туннель при загрузке системы, то придётся [переписать юнит](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Написание_файлов_юнитов "Systemd (Русский)"), чтобы сделать его системным.

### Autossh - автоматический перезапуск сессий и туннелей SSH

Если сессия или туннель не может поддерживаться в активном состоянии, например, из-за плохого подключения к сети и связанных с ним отключений, используйте [autossh](https://www.archlinux.org/packages/?name=autossh) для автоматического перезапуска.

Примеры использования:

```
$ autossh -M 0 -o "ServerAliveInterval 45" -o "ServerAliveCountMax 2" *имя_пользователя*@example.com

```

Совместно с [SSHFS](/index.php/SSHFS "SSHFS"):

```
$ sshfs -o reconnect,compression=yes,transform_symlinks,ServerAliveInterval=45,ServerAliveCountMax=2,ssh_command='autossh -M 0' *имя_пользователя*@example.com: /mnt/example

```

Подключение через SOCKS-прокси, сконфигурированный при помощи [настроек proxy](/index.php/Proxy_settings "Proxy settings"):

```
$ autossh -M 0 -o "ServerAliveInterval 45" -o "ServerAliveCountMax 2" -NCD 8080 *имя_пользователя*@example.com

```

При помощи опции `-f` autossh может быть запущен в качестве фонового процесса. Однако, в этом случае вы не сможете вводить пароль в интерактивном режиме.

Сессия будет завершена, как только вы введете команду `exit`, иначе процесс autossh получит сигнал SIGTERM, SIGINT или SIGKILL.

#### Автозапуск Autossh при загрузке системы при помощи systemd

Если вы хотите, чтобы autossh запускался автоматически, вы можете использовать systemd. Например, вы можете создать файл юнита, подобный этому:

 `/etc/systemd/system/autossh.service` 
```
[Unit]
Description=AutoSSH service for port 2222
After=network.target

[Service]
Environment="AUTOSSH_GATETIME=0"
ExecStart=/usr/bin/autossh -M 0 -NL 2222:localhost:2222 -o TCPKeepAlive=yes foo@bar.com

[Install]
WantedBy=multi-user.target

```

Здесь `AUTOSSH_GATETIME=0` — это переменная окружения, указывающая, как долго ssh должен быть поднят, прежде чем autossh утвердит успешное подключение. Установка значения 0 укажет autossh игнорировать неудачное подключение ssh. Это может быть полезно при добавлении autossh в автозагрузку. Другие переменные окружения доступны на справочной странице [autossh(1)](https://jlk.fjfi.cvut.cz/arch/manpages/man/autossh.1). Конечно, вы можете сделать этот юнит более комплексным, если вам это необходимо (для получения дополнительных подробностей смотрите документацию systemd); очевидно, вы можете использовать ваши собственные опции для autossh, но учтите, что флаг `-f`, подразумевающий `AUTOSSH_GATETIME=0`, не работает с systemd.

Не забудьте [запустить](/index.php/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%8C "Запустить") и/или [включить](/index.php/%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D1%8C "Включить") службу.

Мы также можете отключить ControlMaster, например:

```
ExecStart=/usr/bin/autossh -M 0 -o ControlMaster=no -NL 2222:localhost:2222 -o TCPKeepAlive=yes foo@bar.com

```

**Совет:** Можно создать несколько процессов autossh, если нужно поддерживать несколько туннелей. Просто создайте нужное количество файлов служб с разными именами.

### Альтернатива на случай невозможности запустить демон SSH

Для удалённых или [headless](https://en.wikipedia.org/wiki/Headless_computer в этом случае может помочь, если воспользоваться опцией `OnFailure`.

Предположим, что на сервере работает `sshd`, а качестве запасного варианта выбран [telnet](/index.php/Telnet "Telnet"). Создайте файл, который показан ниже. [Включать](/index.php/%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D0%B8%D1%82%D0%B5 "Включите") `telnet.socket` **не надо**!

 `/etc/systemd/system/sshd.service.d/override.conf` 
```
[Unit]
OnFailure=telnet.socket

```

Это всё. Telnet не будет работать, если запущен `sshd`. Если же `sshd` не запустится, то можно будет создать сеанс telnet для устранения неисправностей.

### Настройка цвета фона терминала для удалённого хоста

Чтобы проще было понять, на каком хосте вы сейчас работаете, можно [задать фон терминала для каждой машины](https://bryangilbert.com/post/etc/term/dynamic-ssh-terminal-background-colors/).

К сожалению, это работает не для всех терминалов (только для [Zsh](/index.php/Zsh_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Zsh (Русский)")).

### Настройка для работы в конкретной сети

С помощью параметра `Match exec` можно создавать настройки хостов для работы в конктретных сетях.

Например, если используется *nmcli* и соединение настроено (вручную или с помощью DHCP) на использование search-domain:

```
Match exec "nmcli | grep domains: | grep example.com"
  CanonicalDomains example.com
  # Should you use a different username on this network
  #User username
  # Use a different known_hosts file (for private network or synchronisation)
  #UserKnownHostsFile <network>_known_hosts

```

### Проверка ключей хостов в локальных сетях

У серверов, находящихся в разных приватных сетях, IP-адреса могут совпадать. Нужен какой-то способ их различать.

Лучшим решением будет воспользоваться рекомендациями из раздела [#Настройка для работы в конкретной сети](#Настройка_для_работы_в_конкретной_сети) и использовать разные параметры `UserKnownHostsFile` для разных сетей. Второй способ лучше использовать, если вы работаете в новых или экспериментальных сетях — просто игнорируйте ключи хостов (hostkeys) для приватных сетей:

```
Host 10.* 192.168.*.* 172.31.* 172.30.* 172.2?.* 172.1?.*
    # Disable HostKey verification
    # Trust HostKey automatically
    StrictHostKeyChecking no
    # Do not save the HostKey
    UserKnownHostsFile=/dev/null
    # Do not display: "Warning: Permanently Added ..."
    LogLevel Error

```

**Важно:** В рабочих сетях используйте только имя хоста для удалённого доступа к нему и/или используйте отдельный файл `known_hosts` для каждой сети.

### Выполнение команд во время входа

Если вы работаете в интерактивном сеансе, существует несколько способов выполнить команду при входе в систему:

*   отредактируйте файл `authorized_keys` на удалённом хосте (см. [sshd(8)](https://jlk.fjfi.cvut.cz/arch/manpages/man/sshd.8#AUTHORIZED_KEYS_FILE_FORMAT));
*   отредактируйте файл `~/.ssh/rc` на удалённом хосте, если сервер работает с включённой опцией `PermitUserRC`;
*   отредактируйте файл настроек командной оболочки, например, `.bashrc`.

## Решение проблем

### Проверка

Проверьте следующие моменты, прежде чем искать решение проблем.

1.  Каталог с настройками `~/.ssh` и его содержимое должно быть доступно только пользователю (проверьте и клиент, и сервер), а также права на запись в домашнем каталоге должны быть только у пользователя:
    ```
    $ chmod go-w ~
    $ chmod 700 ~/.ssh
    $ chmod 600 ~/.ssh/*
    $ chown -R $USER ~/.ssh

    ```

2.  Убедитесь, что открытый ключ клиента (например, `id_rsa.pub`) указан в файле `~/.ssh/authorized_keys` на сервере;
3.  Убедитесь, что вы не ограничили доступ через SSH параметрами `AllowUsers` и `AllowGroups` в [настройках сервера](#Настройка_2);
4.  Проверьте, установил ли пользователь пароль. Иногда новые пользователи не устанавливают пароль до первого входа в систему;
5.  Добавьте параметр `LogLevel DEBUG` в файл `/etc/ssh/sshd_config`;
6.  Изучите вывод команды `journalctl -xe` на предмет сообщений об ошибках;
7.  [Перезапустите](/index.php/%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5 "Перезапустите") демон `sshd` и выполните выход/вход на клиенте и сервере.

### Подключение отклонено или проблема тайм-аута

#### Проброс портов

Если ваша машина находится за NAT или маршрутизатором (скорее всего так и есть, если речь не идёт о VPS или хосте с публичным IP-адресом), убедитесь, что маршрутизатор пробрасывает входящие SSH-соединения на неё. Узнайте внутренний IP-адрес сервера командой `ip addr` и настройте маршрутизатор пробрасывать TCP на SSH-порт этого адреса. Подробности смотри на [https://portforward.com/](https://portforward.com/).

#### SSH запущен и прослушивает?

Утилита *ss* покажет все процессы, прослушивающие TCP-порты:

```
$ ss --tcp --listening

```

Если в выводе окажется, что система не прослушивает порт `ssh`, то SSH не запущен: проверьте файл `/var/log/messages` на предмет сообщений об ошибках.

#### Имеются ли правила фаервола, блокирующие соединения?

[Iptables](/index.php/Iptables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Iptables (Русский)") может блокировать подключения к порту `22`. Проверьте это следующей командой:

```
# iptables -nvL

```

Просмотрите вывод на предмет правил, которые могут блокировать нужные вам пакеты (цепочка `INPUT`). Затем, если необходимо, разблокируйте порт командой вида:

```
# iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT

```

Информацию по настройке межсетевых экранов можно найти в разделе [Файрвол](/index.php/%D0%A4%D0%B0%D0%B9%D1%80%D0%B2%D0%BE%D0%BB "Файрвол").

#### Трафик доходит до вашего компьютера?

Запустите дамп трафика на компьютере, с которым возникли проблемы:

```
# tcpdump -lnn -i any port ssh and tcp-syn

```

Будет показана некоторая базовая информация. Подождите совпадения. После этого попробуйте подключиться вновь. Если вы не видите никакого вывода команды, когда вы пытаетесь подключиться, это значит, что что-то вне вашего компьютера блокирует трафик (это может быть аппаратный фаерволл, роутер NAT и т.д.).

#### Ваш провайдер или кто-то еще блокирует нужный порт?

**Примечание:** Пробуйте этот шаг в том случае, если вы **знаете**, что у вас не запущено никаких фаерволлов, и что вы настроили роутер на DMZ или проброс портов на компьютер. Здесь вы найдете рекомендации по диагностике и возможные решения.

В некоторых случаях провайдер может блокировать порт по умолчанию (SSH порт 22). Чтобы это проверить, создайте сервер на всех интерфейсах (0.0.0.0) и подключитесь удаленно.

Если вы получите сообщение об ошибке вроде этого:

```
ssh: connect to host www.inet.hr port 22: Connection refused

```

это означает, что порт **не** был заблокирован провайдером: просто на сервере не запущен SSH для этого порта (смотрите статью [Безопасность через неясность](https://en.wikipedia.org/wiki/ru:%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D0%BD%D0%B5%D1%8F%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C "wikipedia:ru:Безопасность через неясность")).

Однако, если вы получите сообщение об ошибке вроде этого:

```
ssh: connect to host 111.222.333.444 port 22: Operation timed out 

```

это означает, что что-то отклоняет ваш трафик TCP, предназначенный для порта 22\. Как правило, этот порт скрыт либо вашим фаерволлом, либо третьей стороной (например, провайдером, блокирующим и/или отклоняющим входящий трафик на порт 22). Если вы знаете, что фаерволл на вашем компьютере не запущен и Гремлины не размножаются на ваших роутерах и свитчах, это означает, что провайдер блокирует трафик.

Чтобы убедиться в этом, вы можете запустить Wireshark на сервере и "прослушать" трафик, предназначенный для порта 22\. Поскольку Wireshark является утилитой анализа трафика на уровне 2 , а TCP/UDP используют уровень 3 и выше (смотрите статью [TCP/IP](https://en.wikipedia.org/wiki/ru:TCP/IP "wikipedia:ru:TCP/IP")), если вы ничего не получаете при создании удаленного подключения, вероятнее всего, что третья сторона блокирует трафик для этого порта на вашем сервере.

##### Диагностика

[Установите](/index.php/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B5 "Установите") либо [tcpdump](https://www.archlinux.org/packages/?name=tcpdump), либо Wireshark из пакета [wireshark-cli](https://www.archlinux.org/packages/?name=wireshark-cli).

Для tcpdump:

```
# tcpdump -ni *интерфейс* "port 22"

```

Для Wireshark:

```
$ tshark -f "tcp port 22" -i *интерфейс*

```

где *интерфейс* — сетевой интерфейс для соединения WAN (для проверки выполните `ip a`). Если вы не получаете никаких пакетов при попытке удаленного подключения, можете быть уверены, что ваш провайдер блокирует входящий на порт 22 трафик.

##### Возможное решение

Вы можете просто использовать другой порт, который провайдером не блокируется. Откройте файл `/etc/ssh/sshd_config` и укажите другой порт. Например, добавьте:

```
Port 22
Port 1234

```

Также удостоверьтесь, что другие строки "Port" закомментированы. Если просто закомментировать строку "Port 22" и прописать "Port 1234", проблема не будет решена, поскольку sshd будет прослушивать лишь порт 1234\. Используйте обе строки для запуска сервера SSH на обоих портах.

[Перезапустите](/index.php/%D0%9F%D0%B5%D1%80%D0%B5%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D0%B5 "Перезапустите") сервер `sshd.service`. Готово! Теперь вам необходимо настроить ваш(и) клиент(ы) на использование другого порта.

#### Read from socket failed: connection reset by peer

Последние версии openssh иногда выдают подобное сообщение при попытке подключения к старым SSH-серверам. Это можно обойти с помощью различных [параметров клиента](#Настройка) (подробнее см. [ssh_config(5)](https://jlk.fjfi.cvut.cz/arch/manpages/man/ssh_config.5)).

Причиной проблемы может быть алгоритм эллиптических кривых `ecdsa-sha2-nistp*-cert-v01@openssh`. Его можно отключить, удалив название алгоритма из списка `HostKeyAlgorithms`.

Если это не помогло, возможно, список алгоритмов слишком длинен. Укажите в параметре `Ciphers` менее длинный список (короче 80 символов). Аналогично можно попробовать сократить список `MACs`.

Также стоит изучить [обсуждение](https://lists.gt.net/openssh/dev/51339) на форуме openssh.

### "[ваша командная оболочка]: No such file or directory" / ssh_exchange_identification problem

Одна из возможных причин - необходимость найти абсолютный путь (который возвращает команда `whereis -b [ваша командная оболочка]`, например) в `$SHELL`, даже если бинарный пакет вашего интерпретатора находится в одной из записей `$PATH`.

### Ошибки "Terminal unknown" и "Error opening terminal"

Если вы получаете одну из таких ошибок во время входа, это значит, что сервер не может распознать ваш терминал. Приложения ncurses вроде nano могут не запуститься, выдав сообщение "Error opening terminal".

Правильным решением будет установить файл terminfo клиентского терминала на сервер. Тогда консольные программы на сервере будут знать, как правильно взаимодействовать с вашим терминалом. Информацию о текущем terminfo можно получить с помощью команды `infocmp`, после чего нужно выяснить, [какому пакету он принадлежит](/index.php/Pacman_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#Запросы_к_базам_данных_пакетов "Pacman (Русский)").

Если [установить](/index.php/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B5 "Установите") файл нормально не удаётся, скопируйте его в домашний каталог на сервере:

```
$ ssh myserver mkdir -p  ~/.terminfo/${TERM:0:1}
$ scp /usr/share/terminfo/${TERM:0:1}/$TERM myserver:~/.terminfo/${TERM:0:1}/

```

После выхода и отключения от сервера проблема должна решиться.

#### Хак $TERM

**Примечание:** Это должно быть последним средством.

Можно задать переменную окружения сервера `TERM=xterm` (например, в файле `.bash_profile`). Это заглушит сообщения об ошибках и позволит запуститься приложениям ncurses, но результатом может стать странное поведение и графические баги — кроме случая, если контрольные последовательности вашего терминала совпадают с таковыми у xterm.

### Ошибка Connection closed by x.x.x.x [preauth]

Если вы получили такое сообщение об ошибке, убедитесь, что настроен верный HostKey:

```
HostKey /etc/ssh/ssh_host_rsa_key

```

### id_dsa не используется в OpenSSH 7.0

OpenSSH 7.0 прекратил использование открытых ключей DSA из соображений безопасности. Если вам очень нужно именно эти ключи, воспольуйтесь [опцией](#Настройка) `PubkeyAcceptedKeyTypes +ssh-dss` (на странице [http://www.openssh.com/legacy.html](http://www.openssh.com/legacy.html) она не упомянута).

### Не удаётся подобрать способ обмена ключами в OpenSSH 7.0

OpenSSH 7.0 прекратил использование алгоритма diffie-hellman-group1-sha1, поскольку он ненадёжный и теоретически может быть взломан т.н. атакой Logjam (см. [http://www.openssh.com/legacy.html](http://www.openssh.com/legacy.html)). Если этот алгоритм будет нужен какому-то хосту, ssh выдаст соощение об ошибке следующего содержания:

```
Unable to negotiate with 127.0.0.1: no matching key exchange method found.
Their offer: diffie-hellman-group1-sha1

```

Лучшим решением будет обновить сервер и отключить использование устаревших алгоритмов. Если это сделать невозможно, вы можете заставить клиент включить алгоритм [параметром](#Настройка) `KexAlgorithms +diffie-hellman-group1-sha1`.

### Сеанс tmux/screen прерывается при разрыве соединения SSH

Если ваши процессы прерываются при завершении сеанса SSH, возможно, что вы используете активацию сокета и [systemd](/index.php/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Systemd (Русский)") принудительно её убивает. В этом случае есть два решения. Первый — не использовать активацию сокета и заменить `ssh.socket` на `ssh.service`. Второй — задать параметр `KillMode=process` в разделе `Service` файла `ssh@.service`.

Параметр `KillMode=process` может также быть полезен при работе с классическим `ssh.service`, т.к. он не позволяет убить процесс сессии SSH или процессы [screen](https://www.archlinux.org/packages/?name=screen) и [tmux](https://www.archlinux.org/packages/?name=tmux) при остановке или перезагрузке сервера.

### Сеанс SSH не отвечает

SSH реагирует на [команды управления](https://en.wikipedia.org/wiki/Software_flow_control "wikipedia:Software flow control") `XON` и `XOFF`. Он остановится, если вы случайно нажали `Ctrl+s`. Нажмите `Ctrl+q`, чтобы продолжить сеанс.

### Broken pipe

Если вы пытаетесь установить соединение и получаете ответ `Broken pipe` на `packet_write_wait`, попробуйте подключиться в режиме отладки. Посмотрите, если ли в выводе сообщений об ошибках:

```
debug3: send packet: type 1
packet_write_wait: Connection to A.B.C.D port 22: Broken pipe

```

Строчка `send packet` указывает на то, что ответный пакет получен не был. Следовательно, проблема заключается в *QoS*. Чтобы уменьшить потерю пакетов, задайте значение параметра `IPQoS`:

 `/etc/ssh/ssh_config` 
```
Host *
    IPQoS reliability

```

Значение `reliability` (`0x04`) должно решить проблему. Также можно задать значения `0x00` и `throughput` (`0x08`).

### Демон медленно запускается после перезагрузки

Если демон запускается необычно долго после перезагрузки (несколько минут), особенно для headless- и виртуализированных серверов, это может быть связано с нехваткой энтропии [[9]](https://bbs.archlinux.org/viewtopic.php?id=241954). Для решения этой проблемы установите [Rng-tools](/index.php/Rng-tools "Rng-tools") или [Haveged](/index.php/Haveged_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) "Haveged (Русский)"). Однако обратите внимание на вопросы безопасности, которые обсуждаются в посвящённых этим утилитам статьях.

## Смотрите также

*   [Защита от атак перебором](http://www.la-samhna.de/library/brutessh.html)
*   Управление ключами OpenSSH: [Часть 1](http://www.ibm.com/developerworks/library/l-keyc/index.html) на IBM developerWorks, [Часть 2](https://www.funtoo.org/OpenSSH_Key_Management,_Part_2), [Часть 3](https://www.funtoo.org/OpenSSH_Key_Management,_Part_3) на funtoo.org
*   [Secure Secure Shell](https://stribika.github.io/2015/01/04/secure-secure-shell.html)